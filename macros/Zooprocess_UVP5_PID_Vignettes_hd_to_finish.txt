// -------------------------- Zooprocess_UVP5_PID_Vignettes --------------------------
version = "7.20";
date = "2015/08/13";

// Gestion du cas MIXT et CHOICE > 1

args = 	getArgument();
arg = 	split(args," ");

path = 			arg[0];
profileprocessed = 	arg[1];
profileprocesseddat = 	arg[1]+"_datfile.txt";
profileprocessedbru = 	arg[1]+".bru";
configfile = 		arg[2];
instrum = 		arg[3];
firstimg = 		arg[4];
profileraw = 		arg[5];
firstimg = 		parseInt(firstimg);
endimg = 		1000000000000000;
//	aa = getBoolean("endimg= "+endimg);
if (arg.length == 8) 	{
	endimg = parseInt(arg[6]);
	yoyo_opt = arg[7];
} // if

pathraw = 		path+"\\raw\\";
pathresults = 		path+"\\results\\";
pathprocessed = 	path+"\\work\\"+profileprocessed+"\\";
pathconfig = 		path+"\\config\\";
profile = 		profileprocessed;						// a remplacer dans le soft si OK
pathpidresults = 	path+"\\"+"\\PID_process\\"+"\\Pid_results\\";
hdr_file_work =		pathprocessed+"\\"+profileraw +".txt";
hdr_file_raw =		pathraw+profileraw+"\\"+profileraw +".hdr";
pathrawvig = 		pathraw+profileraw+"\\";
openbru = 		pathprocessed + profileprocessedbru;
pressure_file = 	pathconfig+"pressure_gain.txt";
parametres2 = "NaN";
parametres3 = "NaN";

//	aa = getBoolean(hdr_file_raw);
//	aa = getBoolean(hdr_file_work);
//	aa = getBoolean("firstimg= "+firstimg+"   endimg= "+endimg);

// --------------------------- NOTE -----------------------------------------------------------------------------------------------------
// L'aire initiale n'est calculée que si "process_option = advancedi" et non "process_option = advanced"

// --------------------------------------------------------- Mode TEST ----------------------------------------------------------------
batch =		true;
test = 		"0";
if (test == "1")  { batch =		"false";	getBoolean("MODE TEST ! Continue ?");	} // if
print("A purger");	selectWindow("Log");		run("Close");
run("Colors...", "foreground=black background=white selection=red");

// ----------------------------------------------- Parametres CONFIG ------------------------------------------------------------------
openconfig = pathconfig +"\\"+configfile;
open(openconfig);
wait(100);
config = getInfo();
run("Close");
conf  = split(config,"\n");
size = conf.length;
array = newArray(size);
for (i=0; i<conf.length; i++)	{ texte = conf[i];	ssarray = split(texte," ");	array[i] = ssarray[1];		} // for
if (instrum == "UVP5") {
	calibration = 		array[0];
	pixel=			array[1];
	upper= 			array[2];			// pour Area
	upper = 		parseInt(upper);
	gamma= 			array[3];
	echelle_mm= 		array[4];
	process_option= 	array[5];
	profmin= 		array[6];
	esdmin= 		array[7];
	esdmax= 		array[8];
	threshold= 		array[9];		// celui du HDR pour BRU et Areai
	smzoo= 			array[10];
	smzoo = 		parseInt(smzoo);
	ratio = 		array[11];
	Larg= 			array[12];
	Haut= 			array[13];
	scale= 			array[14];
} // if
areamin_from_config = true;
if (conf.length == 16 ) {	areamini= array[15];	areamin = parseInt(areamini);	} //
else { areamin_from_config = false;							} // 		

thresholda = 255 - parseInt(threshold);
processvignettes = 	1;
echelletext = 	echelle_mm+ " mm ";
voxelwidth= 	1;
voxelheigth= 	1;
voxeldepth= 	1;
voxelunit = 	"pixel";
param = 	"1";
TAG = 		0;
flagimg = 	0;
gamma = "value="+gamma;
image0text = "initial";
image_end_text = "not_defined";
clean = false;
back = true;
backdif = 255 - upper-3;
uvp5_hd_image_size = 4195382;
uvp5_image_size = 1229878;
image_type = "no";

// ----------------------- Conversions  ----------------------------------------------------
echelle_mm = 	parseInt(echelle_mm);
scale = 	parseInt(scale);
longline = 	scale*echelle_mm/pixel;

// ----------------------- Pixel size ---------------------------------------------------------
Smmin=(3.1416/4)*pow(esdmin,2);
Spmin = round(Smmin/(pow(pixel,2)));			// 20
Smmax=(3.1416/4)*pow(esdmax,2);
Spmax = round(Smmax/(pow(pixel,2)));		// 10000

// =========================== TESTS =======================================

// -------------------------- Verification PRESSURE GAIN -------------------
pressure_gain = 10;
if (File.exists(pressure_file)) {
	open(pressure_file);
	wait(100);
	pressure_gain = getInfo();
	pressure_gain = parseFloat(pressure_gain);
	run("Close");	
}

// --------------------------- R Existence du HDR*.hdr ou HDR*.txt -------------------------------------------------
TaskType_hdr= 0;
Thresh_hdr= 0;
SMbase_hdr = 0;
SMzoo_hdr = 0;
vignette_choice = -999999;
hdr_data = false;	
uvp_type = "std";
if (File.exists(hdr_file_work)) {
	open(hdr_file_work);
	wait(100);
	data = getInfo();
	run("Close");
	hdr_data = true;		
}//
else if (File.exists(hdr_file_raw)){
	File.rename(pathraw+profileraw +".hdr",pathraw+profileraw +".txt");
	open(hdr_file_raw);
	wait(100);
	data = getInfo();
	run("Close");	
	hdr_data = true;		
	File.rename(pathraw+profileraw +".txt",pathraw+profileraw +".hdr");		
}
if (hdr_data == true ) {
	// -------------- Type d'UVP5 ------------------------------
	if (indexOf(data,"uvp5hd")> 0) uvp_type = "hd";
	conf  = split(data,"\n");
	description = conf[1];
	if (lengthOf(description) >0) {
		long = lengthOf(description);
		description = substring(description,1,long);
		print("File_description= "+description);
	}
	for (i=1;i<conf.length;i++){
		file = conf[i];
		if (lengthOf(file) > 3) {
			if (startsWith(file,"TaskType="))	{	file = replace(file,"="," "); data = split(file," "); TaskType_hdr=data[1];		TaskType_hdr = parseInt(TaskType_hdr);				}
			else if (startsWith(file,"Thresh=")) {		file = replace(file,"="," "); data = split(file," "); Thresh_hdr=data[1];		Thresh_hdr = parseInt(Thresh_hdr);	}
			else if (startsWith(file,"SMbase=")){ 		file = replace(file,"="," "); data = split(file," "); SMbase_hdr=data[1];		SMbase_hdr = parseInt(SMbase_hdr);	}
			else if (startsWith(file,"SMzoo=")) {		file = replace(file,"="," "); data = split(file," "); SMzoo_hdr=data[1];		SMzoo_hdr = parseInt(SMzoo_hdr);	}
			else if (startsWith(file,"Choice=")) {		file = replace(file,"="," "); data = split(file," "); vignette_choice=data[1];		vignette_choice = parseInt(vignette_choice);	}
		} // if length
	} // for
} //if	
// --------------------------- Détermination du type d'images à traiter selon HDR ou observation -------------------

// --------------- A MODIFIER pour UVP5HD ------------------
// --------------------------- V W T Presence d'images entières / vignettes dans le répertoire du profil ---------------

// ----------- recherche des infos sur le nb d'images ou vignettes ----------------
	filelist = getFileList(pathrawvig);
	j = 0;
	m = 0;
	pos = 0;
	flag = 0;
	list = newArray(filelist.length);
	for (i = 0;i<filelist.length;i++) {
		nomvig =filelist[i];
		pathvig = pathraw+profileraw+"\\"+nomvig;
		size = File.length(pathvig);
		size = parseFloat(size);
		if (endsWith(nomvig,".bmp") == true  )  {		rr = filelist[i]; 	list[j] = rr; 	j++;	} // if
		if (endsWith(nomvig,".bmp") == true && size == uvp5_image_size  ) 	{	m++;		} // if		Cas image entiere 
	} // for
	if (j >= 1) {
		listaff = newArray(j);
		for (i=0; i<listaff.length ; i++) {	rr = list[i]; 	listaff[i] = rr;	} // for
	
	} // if
	if ( j != 0 && j > m ) 	image_type = "vig";		// plus de fichiers bmp que d'images entières
	if ( j != 0 && m == j ) image_type = "full_img";	// toutes les bmp sont entières	

 if (hdr_data == true ) {
	 // ----------- Si fichier HDR -------------------
	if (TaskType_hdr == 2 && vignette_choice == 0) 		image_type = "vig";
	else if (TaskType_hdr == 2 && vignette_choice == 1) 	image_type = "full_img";
	else if (TaskType_hdr == 2 && vignette_choice > 1) 	image_type = "mixt";
}



aa = getBoolean("hdr_data: "+hdr_data+"  m: "+m+" image_type: "+image_type);


// --------------------------- Si pas d'area min dans CONFIG, alors on prend celle du HDR et 0 sinon ---------------
if (areamin_from_config == false) areamini = SMbase_hdr;

// --------------------------- S Comparaison HDR/Config ------------------------------------------------------------
hdr_equal_config = true;
if (SMbase_hdr != areamini || SMzoo_hdr != smzoo || Thresh_hdr != (256 - upper)) hdr_equal_config = false;
//*	a = getBoolean("image_type= "+image_type+" TaskType_hdr= "+TaskType_hdr+" hdr_data=b "+hdr_data+"  SMbase_hdr= "+SMbase_hdr+" areamini= "+areamini+" SMzoo_hdr= "+SMzoo_hdr+" smzoo= "+smzoo+" Thresh_hdr= "+Thresh_hdr+" upper=" +upper );

//------------- Ouverture du fichier  DAT reduit dans le repertoire final du profil ----------------
open(pathprocessed+profileprocesseddat);
wait(100);
data = getInfo();
wait(100);
run("Close");
ligne = split(data,"\n");	

// --------------------------- U Vérification que toutes les images full existent pour le DAT ------------------------
reprocess_dat = true;
if (image_type == "full_img") {
	for (i=0; i<ligne.length ; i++) {
		dataline = 	ligne[i];
		dataline = 	replace(dataline,";"," ");
		dataline = 	split(dataline," ");
		noimg = 	dataline[0];
		noimg = 	parseInt(noimg);
		vigname = 	dataline[1];			// Nom image source
		vignb = 	parseInt(vignb);
		long = 		lengthOf(vigname);
		vig_img = 	substring(vigname,1,long);
		if (noimg >= firstimg && noimg <= endimg && File.exists(pathraw+profileraw+"\\"+vig_img+".bmp" ) == false ) reprocess_dat = false;
	} // for
} // if

// ============================ SYNTHESE ===============================================================
process_type = "no";
if (hdr_data == true && TaskType_hdr == 0 && reprocess_dat == true ) 		process_type = "A";
else if (hdr_data == true && TaskType_hdr == 2 && image_type == "full_img" ) 	process_type = "C";
else if (hdr_data == true && TaskType_hdr == 2 && image_type == "vig" ) 	process_type = "D";
else if (hdr_data == true && TaskType_hdr == 2 && image_type == "mixt" ) 	process_type = "E";
else if (hdr_data == true && TaskType_hdr == 3 && hdr_equal_config == true ) 	process_type = "C";
else if (hdr_data == true && TaskType_hdr == 3 && hdr_equal_config == false ) process_type = "A";
else if (hdr_data == false && image_type == "vig" )				process_type = "D";
else if (hdr_data == false && image_type == "full_img" && reprocess_dat == true && File.exists(openbru) == false) process_type = "A";
else if (hdr_data == false && image_type == "full_img" && reprocess_dat == true && File.exists(openbru) == true) process_type = "C";
// cas mixt sauve image entière ou full avec images corrompues
else if (hdr_data == false && image_type == "full_img" && reprocess_dat == false ) process_type = "C";					
else {	 process_type = "B";	} // else

//	aa = getBoolean("hdr_data= "+hdr_data+" TaskType_hdr= "+TaskType_hdr+" image_type= "+image_type+" reprocess_dat= "+reprocess_dat+" hdr_equal_config= "+hdr_equal_config);
//	aa = getBoolean(process_type);

// -------------------- Si process A : bru & dat et vignettes from img, si C : vignettes from img --------------------------------
if ( process_type == "A" || process_type == "C" || process_type == "E" ) { 
	argum = pathraw+" "+firstimg+" "+profileraw+" "+threshold+" "+smzoo+" "+ratio+" "+Larg+" "+Haut+" "+endimg+" "+pathprocessed+" "+profileprocesseddat+" "+profileprocessedbru+" "+process_type+" "+areamini+" "+pathresults+" "+endimg+" "+yoyo_opt+" "+uvp_type;	
	ret = runMacro("Zooprocess_UVP5_vignettes_from_image",argum);
	flag=toString(ret);
	l= lengthOf(flag);
	if (l==1)  { 	getBoolean("Image to vignette process aborted. \nPress Cancel to abort !    ");		} // if
	else if (process_type == "A") { 
		pathrawvig = flag;
		//------------- Ouverture du NOUVEAU fichier DAT reduit dans le repertoire final du profil ----------------
		open(pathprocessed+profileprocesseddat);
		wait(100);
		data = getInfo();
		wait(100);
		run("Close");
		ligne = split(data,"\n");
	}
	else { 	pathrawvig = flag;	} // else
} // if

// ---------------- liste des images pour lesquelles une vignette existe Indexation profondeur -------------------------
vignumber = 0;
nn = 1000*j;				// Par precaution, car on a enleve des vignettes en surface !
//  ms valeur trop faible debordement;
Vigname = 	newArray(nn);
Vigdepth = 	newArray(nn);
Vigimg =	newArray(nn);

// ----------------Premiere image defaut ---------------------------------------------
dataline = 	ligne[0];
dataline = 	replace(dataline,";"," ");
dataline = 	split(dataline," ");
vigname = 	dataline[1];			// Nom image source

image0 = substring(vigname,0,14);	
image0text = image0;
for (i=0; i<ligne.length ; i++) {
	dataline = 	ligne[i];
	dataline = 	replace(dataline,";"," ");
	dataline = 	split(dataline," ");
	vigname = 	dataline[1];			// Nom image source
	vigdepth =	dataline[2];			// Immersion
	vignb = 	dataline[17];			// Nombre de vignettes dans l'image
	vignb = 	parseInt(vignb);
	noimg = 	dataline[0];
	// --------------- Nom de la premiere image a conserver ------------------
	if (noimg == firstimg) { image0 = substring(vigname,0,14);	image0text = image0;	} // if
	// --------------- Nom de la dernière image a conserver ------------------
	if (noimg == endimg) { image_end = substring(vigname,0,14);	image_end_text = image_end;	} // if
	if (vignb != 0) {
		for (m = 0;m<vignb;m++) {
			Vigname[vignumber] = 	vigname;			// Nom image source
			vigdepth =		parseFloat(vigdepth);			// Immersion
			// depth positif
			vigdepth = maxOf(vigdepth,0);
			Vigdepth[vignumber] =	vigdepth/pressure_gain;
			Vigimg[vignumber] = 	dataline[0];			// N° de l'image dans le datfile
			vignumber++;	
		} // for
	} // if
} // for
if (image_end_text == "not_defined") { image_end = substring(vigname,0,14);	image_end_text = image_end;	} // if
nbimgsource = vignumber;
//	if (vignumber == 0) aa = getBoolean("BRU file not processed ! \n \nPRESSS CANCEL to ABORT !");

// -------------------- Verification liste des vignettes -----------------------------
filelist = getFileList(pathrawvig);
j = 0;
pos = 0;
list = newArray(filelist.length);
for (i = 0;i<filelist.length;i++) {
	nomvig =filelist[i];
	pos = endsWith(nomvig,".bmp");
	pathvig = pathrawvig+"\\"+nomvig;
	size = File.length(pathvig);
	size = parseInt(size);
	if (pos == true  && size < 1200000)  {rr = filelist[i]; 	list[j] = rr; 	j++;	
		//	print("i= "+i+"   Vignette= "+rr);	
	} // if
} // for
//	print("Fin liste A");
if (j >= 1) {
	listaff = newArray(j);
	for (i=0; i<listaff.length ; i++) {	rr = list[i]; 	listaff[i] = rr;		
//		print("i= "+i+"   Vignette= "+rr);		
	} // for
	if (flagimg == 1) vignumber = j;
} // if
//	else { getBoolean("No vignette available in "+pathrawvig+" ! \nPress Cancel to abort !");	}//else
// --------------- Process PID vignette par vignette ---------------------
if ( process_type != "B" ) {
	// -------------- Vecteurs -------------------------------
	nbblobs = 	j;
	Img = 		newArray(nbblobs);
	XSTART = 	newArray(nbblobs);
	YSTART = 	newArray(nbblobs);
	BX = 		newArray(nbblobs);
	BY = 		newArray(nbblobs);
	WIDTH = 		newArray(nbblobs);
	HEIGTH = 	newArray(nbblobs);
	Area = 		newArray(nbblobs);
	Areai = 	newArray(nbblobs);
	Mean =		newArray(nbblobs);
	StdDev = 		newArray(nbblobs);
	Mode = 		newArray(nbblobs);
	Min = 		newArray(nbblobs);
	Max = 		newArray(nbblobs);
	X = 		newArray(nbblobs);
	Y = 		newArray(nbblobs);
	XM = 		newArray(nbblobs);
	YM = 		newArray(nbblobs);
	Perim = 		newArray(nbblobs);
	Major = 		newArray(nbblobs);
	Minor = 		newArray(nbblobs);
	Angle = 		newArray(nbblobs);
	Circ = 		newArray(nbblobs);
	Feret = 		newArray(nbblobs);
	IntDen = 		newArray(nbblobs);
	Median = 		newArray(nbblobs);
	Skew = 		newArray(nbblobs);
	Kurt = 		newArray(nbblobs);
	PArea = 		newArray(nbblobs);
	Area_exc = 	newArray(nbblobs);
	Fractal = 		newArray(nbblobs);
	Skelarea = 	newArray(nbblobs);

	Slope = 		newArray(nbblobs);
	Histcum1 =	newArray(nbblobs);		
	Histcum2 =	newArray(nbblobs);
	Histcum3 =	newArray(nbblobs);
	XMg5 = 		newArray(nbblobs);
	YMg5 = 		newArray(nbblobs);
	nbA =		newArray(nbblobs);
	nbB =		newArray(nbblobs);
	nbC =		newArray(nbblobs);
	compentropy =	newArray(nbblobs);
	compmean = 	newArray(nbblobs);
	compslope = 	newArray(nbblobs);
	compm1 =	newArray(nbblobs);
	compm2 =	newArray(nbblobs);
	compm3 =	newArray(nbblobs);
	symetrieh =	newArray(nbblobs);
	symetriev =	newArray(nbblobs);
	symetriehc =	newArray(nbblobs);
	symetrievc =	newArray(nbblobs);
	convperim =	newArray(nbblobs);
	convarea =	newArray(nbblobs);
	fcons =		newArray(nbblobs);
	ratio = 		newArray(nbblobs);
	Depth = 		newArray(nbblobs);

	// -------------------- BOUCLE PRINCIPALE sur les vignettes ------------------------------------------------------------------------------------
	setBatchMode(batch);
	totalvig = 0;
	indexvignette = 0;
	precimage = "debut_traitement_image_uvp5";
	for (i=0; i<nbimgsource; i++) {
		//	showProgress(i/nbimgsource);
		long = lengthOf(Vigname[i]);
		image = substring(Vigname[i],1,long);
		if (startsWith(image,precimage)) {	 indexvignette++;			} // if
		else { 					indexvignette = 0;		} // else
		if (indexvignette < 10) 		image = image+"_000"+indexvignette+".bmp";
		else if (indexvignette < 100) 	image = image+"_00"+indexvignette+".bmp";
		else if (indexvignette < 1000) 	image = image+"_0"+indexvignette+".bmp";
		else {	image = image+"_"+indexvignette+".bmp";		} // else
		longp = lengthOf(image);
		if (longp < 18 ) { aa = getBoolean(image+"    "+longp+"  "+i+"   "+Vigdepth[i]+"    "+Vigimg[i]);			} // if

		precimage = substring(image,0,18);
		
		pathimg = pathrawvig+"\\"+image;
	
		// ------------ Recherche de la profondeur -------------
		vignette = substring(image, 0, 18);
		flag = 0;
		depth = Vigdepth[i];

		// ---------------- Nom vignette ---------------------------------
		vignette = substring(image, 0, 23);
		
		// ----------------- TEST derniere image ---------------------
		facteuri = 1;
		image_end = parseInt(image_end);
		if ((image_end/20000000000000)<1) {	facteuri = 10;	} // if
		image_end_date = 	image_end * facteuri;

		// ----------------- TEST premiere image ---------------------
		facteuri = 1;
		image0 = parseInt(image0);
		if ((image0/20000000000000)<1) {	facteuri = 10;	} // if
		image0date = 	image0 * facteuri;

		facteurv = 1;
		vignettedate = 	substring(vignette,0,14);
		vignettedate = 	parseInt(vignettedate);
		if ((vignettedate/20000000000000)<1) {	facteurv = 10;	} // if
		vignettedate = 	vignettedate * facteurv;
		profimg = parseFloat(depth);

		
//	aa = getBoolean("image0date= "+image0date+"    vignettedate= "+vignettedate+"   image_end_date= "+image_end_date);

//		if (vignettedate == image_end_date) aa = getBoolean("END");
		// ------------------ Vignette existe et apres FIRSTIMGOK et inf a profmin  et inf endimg-------------------------
		if (File.exists(pathimg) && vignettedate >= image0date && vignettedate < image_end_date && profimg >= profmin) { 
					
		//	aa = getBoolean("OK");
			// ---------------- Jusqu'à la profondeur maximale ------------------------
			if (yoyo_opt == "N") {		profmin = maxOf(profimg,profmin);	} // if
			// +++++++++++++++++++++
			Depth[totalvig] = depth;
			// +++++++++++++++++++++
			titrered = profile;

			// --------------- Ouverture vignette -----------
if (test == "1")	 	print("NEW vignette    "+i);
			open(pathimg);
if (test == "2")		saveAs("bmp", pathimg); 
			rename(titrered);
			HH = 	getHeight();		WW = 	getWidth();
			// --------- Inversion ------------------------------
			run("Invert");
			// -------------- Sauvegarde vignette -----------------------------------------------------
			if (processvignettes == 1 ) {
				run("Duplicate...", "title=vignette_to_save");
				// --------- soustraction du fond ----------------
				if (back == true) {
					textback = "value="+backdif;
					run("Add...",textback);
				} // if
				// -------------------------------- Nettoyage complet ------------------------------------------
				if (clean == true) {
					// ------------------- nettoyage RESULTS ---------------------------
					if (isOpen("Results")) { selectWindow("Results");		run('Close');	}
					// ------------------- Copie de travail ---------------------------------
					selectImage("vignette_to_save");
					run("Duplicate...", "title=vignette_msk");

					// ------------------- Threshold ----------------------------------------
					setThreshold(0, upper);
					run("Convert to Mask");

					// ------------------- Nettoyage autour du plus gros objet --------
					run("Set Measurements...", "area centroid bounding fit redirect=[vignette_msk] decimal=2");
					run("Analyze Particles...", "size=0-Infinity circularity=0.00-1.00 show=Nothing exclude include record");
					updateResults();

					nbobj = nResults;
					ligne = 0;		g = 0;		Ratio = 0;
					// ---------------------- Si probleme de vignette blanche -----------------------------------
					if (nbobj == 0) {
						getBoolean("Blank vignette, press Cancel to ABORT !  ");
					} //
					areainit = getResult("Area", ligne);
					ystart =	getResult("YStart", ligne);
					while (g<nbobj) {		
						area = getResult("Area", g);	
						ystart =	getResult("YStart", g);
						if (area > areainit ) ligne = g;
						areainit = maxOf(area,areainit);
						g++;
					} // for
					xstart = 	getResult("XStart", ligne);
					ystart =	getResult("YStart", ligne);
					// --------------- nettoyage autour du plus gros objet -------------
					selectImage("vignette_msk");
					DEBX = xstart;
					DEBY= ystart;
					doWand(DEBX,DEBY);
					run("Clear Outside");
					//	run("Select None");	
					selectImage("vignette_msk");
					run("Select All");
					run("Invert");
					run("Image Calculator...", "image1=vignette_to_save operation=Add image2=vignette_msk");
					selectImage("vignette_msk");
					close();
				} // if clean

				// --------- Gamma -------------------------------
				selectImage("vignette_to_save");
				run("Gamma...", gamma);
				// --------- Resize --------------------------------
				Wfinal = 	WW*scale;
				Hfinal = 	HH*scale;
				text = 	"width="+Wfinal+" height="+Hfinal+" constrain interpolate";
				run("Size...", text);
				// -------- Ajout de l'echelle -----------------------------
				setLineWidth(2);
				setFont("SansSerif", 9);
				Wfinal =	maxOf(Wfinal,longline+30);
				H = 	Hfinal+31;
				text = "width="+Wfinal+" height="+H+" position=Top-Left";
				run("Canvas Size...", text);
				drawString(echelletext,25,Hfinal+10);
				drawLine(10,Hfinal+10,10+longline,Hfinal+10);
				drawLine(10,Hfinal+10,10,Hfinal+7);
				drawLine(10+longline,Hfinal+10,10+longline,Hfinal+7);
				drawString(profile,10,Hfinal+21);
//				drawString(vignette,10,Hfinal+21);
				vignette = substring(image, 0, 23);
				depth = parseFloat(depth);
				depth = toString(depth);
			//	if (lengthOf(depth) == 1) depth = "000"+depth;
			//	if (lengthOf(depth) == 2) depth = "00"+depth;
			//	if (lengthOf(depth) == 3) depth = "0"+depth;
				Imagenbm = Vigimg[i];

				Imagenb = toString(Imagenbm);
if (Imagenb == "0") {	aa = getBoolean(depth+" "+Imagenbm+"    "+i);	} // if
				drawString(Imagenb+"   "+depth+" m",10,Hfinal+30);
				// -------- Enregistrement et fermeture ---------------
				norecord = totalvig+1;
				saveAs("jpg", pathprocessed+titrered+"_"+norecord+".jpg"); 
			//	showMessage(pathprocessed+titrered+"_"+index+".jpg"); 
				close();
			} // if
			selectImage(titrered);
			// +++++++++++++++++++++
			listaff[totalvig] = titrered;
			// +++++++++++++++++++++
			image = titrered;
			
			// ------------------- Mesures principales en niveaux de gris -----------------------------------------
			parametres2 = "area mean standard modal min centroid center perimeter bounding fit circularity feret's integrated median skewness kurtosis area_fraction limit redirect="+titrered+" decimal=2";
			parametres3 = "centroid center redirect=vignette decimal=2";
			
			setVoxelSize(voxelwidth,voxelheigth,voxeldepth,voxelunit);
			run("Duplicate...", "title=vignette");
			run("Duplicate...", "title=vignette_msk");
			
 if (process_option == "advancedi") {
			run("Duplicate...", "title=vignette_mskth");
			// ------------- Calcul AREA avec threshold INITIAL (I2s) Utilise "threshold" -----------------------------------------
			run("8-bit");
			setVoxelSize(1,1,1,voxelunit);
			setThreshold(0, thresholda);
			run("Threshold", "thresholded remaining black");
			if (isOpen("Results")) { selectWindow("Results");		run('Close');	}
			// ---------------------- Nettoyage de la vignette "vignette_msk" et premieres mesures -----------------------------------
			run("Set Measurements...", "area centroid center bounding area_fraction fit limit redirect=[vignette_mskth] decimal=2");
			analysis1 =  "size=1-Infinity circularity=0.00-1.00 bins=20 show=Nothing include flood record";
			run("Analyze Particles...",analysis1);
			updateResults();
			nbobj = nResults;
			ligne = 0;		g = 0;		
			// ---------------------- Recherche plus gros -----------------------------------
			if (nbobj == 0) {	print("Error : "+titrered+"  "+i+"   "+pathimg);		getBoolean("Error "+titrered+"  "+i);		} // if
			areainit = 0;
			while (g<nbobj) {		area = getResult("Area", g);
				x = 	getResult("X", g);
				y = 	getResult("Y", g);		
				h = 	getResult("Height", g);
				if (h != 0 && x != 0 && y != 0 ) {
					if (area > areainit ) 	{	
						ligne = g;	
					} // if
					areainit = maxOf(area,areainit);
				} // if	
				g++;
			} // while		
			area = 	getResult("Area", ligne);
			// ++++++++++++++++++++++++++
			Areai[totalvig] = 		area;			// 20111012
			// ++++++++++++++++++++++++++
			selectImage("vignette_mskth");
			close();
} // if
			// ----------------------- Calcul d'origine --------------------------------------------------
			selectImage("vignette_msk");
			run("8-bit");
			setVoxelSize(1,1,1,voxelunit);
			setThreshold(0, upper);
			run("Threshold", "thresholded remaining black");
			if (isOpen("Results")) { selectWindow("Results");		run('Close');	}

			// ---------------------- Nettoyage de la vignette "vignette_msk" et premieres mesures -----------------------------------
			run("Set Measurements...", "area centroid center bounding area_fraction fit limit redirect=[vignette_msk] decimal=2");
		//	analysis1 =  "size=0-Infinity circularity=0.00-1.00 bins=20 show=Nothing include exclude flood record";
			analysis1 =  "size=1-Infinity circularity=0.00-1.00 bins=20 show=Nothing include flood record";
			run("Analyze Particles...",analysis1);
			updateResults();
			nbobj = nResults;
			ligne = 0;		g = 0;		
			// ---------------------- Recherche plus gros -----------------------------------
			if (nbobj == 0) {	print("Error : "+titrered+"  "+i);		getBoolean("Error "+titrered+"  "+i);		} // if
			areainit = 0;
			while (g<nbobj) {		area = getResult("Area", g);
				bx = 	getResult("BX", g);
				by = 	getResult("BY", g);
				w = 	getResult("Width", g);
				h = 	getResult("Height", g);
				x = 	getResult("X", g);
				y = 	getResult("Y", g);
//				if (bx != 0 && by != 0 && h != 0 && x != 0 && y != 0 ) {
				if (h != 0 && x != 0 && y != 0 ) {
					if (area > areainit ) 	{	
						ligne = g;	
if (test == "1") 					print("1    bx =  "+bx+"   by = "+by+"   h = "+h+"   x = "+x+"   y = "+y+"    CONTINUE ?");			
					} // if
					areainit = maxOf(area,areainit);
				} // if	
				g++;
			} // while		
			bx = 	getResult("BX", ligne);
			by = 	getResult("BY", ligne);
			w = 	getResult("Width", ligne);
			h = 	getResult("Height", ligne);
			x = 	getResult("X", ligne);
			y = 	getResult("Y", ligne);
			area = 	getResult("Area", ligne);
			major = 	getResult("Major", ligne);
			angle = 	getResult("Angle", ligne);
			xstart = 	getResult("XStart", ligne);
			ystart = 	getResult("YStart", ligne);
			parea = 	getResult("%Area", ligne);
			// ++++++++++++++++++++++++++
			Area[totalvig] = 		area;
			PArea[totalvig] = 	parea;
			Area_exc[totalvig] = 	area - area* (0.01 * parea);	
			BX[totalvig] = 		bx;
			BY[totalvig] = 		by;
			WIDTH[totalvig] =	w;	
			HEIGTH[totalvig] =	h;
			XSTART[totalvig] = 	xstart;
			YSTART[totalvig] =	ystart;
			// ++++++++++++++++++++++++++
			//	print("Image = "+i);
			// --------------- nettoyage autour du plus gros objet -------------
			selectImage("vignette_msk");
if (test == "1") 		print("2    Area =  "+area+"   xstart = "+xstart+"   ystart = "+ystart+"    CONTINUE ?");
			DEBX = xstart;
			DEBY= ystart;
			doWand(DEBX,DEBY);
			run("Clear Outside");
if (test == "1") 		print("3    End of CLEAR outside. CONTINUE ?");

			// ------------------- symétrie brute et Ratio  ----------------------	
			image = "vignettesym";
			selectImage("vignette_msk");
			if(isOpen("vignettesym")) { selectImage("vignettesym"); close();	} // if
			run("Duplicate...", "title=vignettesym");
			if (isOpen("Results")) { selectWindow("Results");		run('Close');	}			
			// --------------- Agrandissement de l'image -------------------------
			largeursym = 	WW*1.2;
			hauteursym = 	HH*1.2;
			canvas = "width="+largeursym+" height="+hauteursym+" position=Center";
			selectImage("vignettesym");	
			run("Canvas Size...", canvas);

			// ----------------------- Nettoyage vignette "vignette_sym" -------------------------------
if (test == "1") 		print("10    End of Agrandissement. CONTINUE ?");
			if (isOpen("Results")) { selectWindow("Results");		run('Close');	}
			run("Set Measurements...", "area centroid bounding fit redirect=[vignettesym] decimal=2");
			selectImage("vignettesym");
			run("Analyze Particles...", "size=0-Infinity circularity=0.00-1.00 show=Nothing include record");
			// ------------------ Symetrie du plus gros objet de la vignette ---------------------------
if (test == "1") 		print("Debut Symetrie. CONTINUE ?");
			updateResults();
			nbobj = nResults;
			ligne = 0;		g = 0;		Ratio = 0;
			if (nbobj == 0) {		print("Error Debut Symetrie : "+titrered+"  "+i);	setBatchMode("exit and display");	getBoolean("Error Debut Symetrie : "+titrered+"  "+i);		} // if

//			areainit = getResult("Area", ligne);
			areainit = 0;
			while (g<nbobj) {		area = getResult("Area", g);
				bx = 	getResult("BX", g);
				by = 	getResult("BY", g);
				w = 	getResult("Width", g);
				h = 	getResult("Height", g);
				x = 	getResult("X", g);
				y = 	getResult("Y", g);
//				if (bx != 0 && by != 0 && h != 0 && x != 0 && y != 0 ) {
				if (h != 0 && x != 0 && y != 0 ) {
					if (area > areainit ) 	{	
						ligne = g;	
if (test == "1") 					print("bx =  "+bx+"   by = "+by+"   h = "+h+"   x = "+x+"   y = "+y+"    CONTINUE ?");			
					} // if
					areainit = maxOf(area,areainit);
				} // if	
				g++;
			} // while
			bx = 	getResult("BX", ligne);
			by = 	getResult("BY", ligne);
			w = 	getResult("Width", ligne);
			h = 	getResult("Height", ligne);
			x = 	getResult("X", ligne);
			y = 	getResult("Y", ligne);
			area = 	getResult("Area", ligne);
			major = 	getResult("Major", ligne);
			angle = 	getResult("Angle", ligne);
			xstart = 	getResult("XStart", ligne);
			ystart = 	getResult("YStart", ligne);
			angle = 	angle +180;
			angle = 	toString(angle);
			// --------------- nettoyage autour du plus gros objet -------------
			selectImage("vignettesym");
			DEBX = xstart;
			DEBY= ystart;
			doWand(DEBX,DEBY);
			run("Clear Outside");
			// ---------------- centrage ----------------------
			sum = w*w + h*h;
			diag = pow(sum, 0.5);
			diag = diag * 1.2;
			makeRectangle(bx,by,w,h);
			run("Copy");
			newImage("vignetteA", "8-bit White",diag, diag, 1);
			x = x-bx;
			y = y-by;
			posx = (diag/2)-x;
			posy = (diag/2)-y;
			makeRectangle(posx,posy,w,h);
			run("Paste");
			selectImage("vignetteA");
			run("Make Binary");
			run("Select None");
			rotation = "angle="+angle+" interpolate";
			rotation = "angle="+angle+" grid=1 fill";
			run("Arbitrarily...", rotation);


			//---------------- Vignette A est horizontale sur son grand axe -------------------
			W = diag;		H = diag;
			getHistogram(0, hist, 256);
if (test == "1") 		print("End of Histogram. CONTINUE ?");
			S = newArray(250);
			F = 0;	pa = 0;	pb = 0;	pd = 0;	flag = 0;	max = 0;	min = 1000;	c = 0;		count = 1;
			// ---------  Normalisation de l'intervalle par la taille pixel --------------
			step = floor(0.1/pixel);
			step = maxOf(step,1);
			pointA = newArray(1+W/step);
			pointB = newArray(1+W/step);
			dif = newArray(1+W/step);
if (test == "1") 		print("End of Array. CONTINUE ?");
			//-------- start--vertical search---------------
			for(x=0;x<W;x=x+step)	{
				for(y=0;y<H-1;y=y+1) {
					pa = getPixel(x,y);
                     		  			pb = getPixel(x,y+1);
					pd = abs(pa-pb);
					if(pd > 100 && flag == 0) { 	flag = 1;	pd = 0;		pointA[c]=y;     			} // if
                        	        		if(pd > 100 && flag == 1) {	pointB[c]=y;		flag = 3;		c++;		} // if
				} // for
				flag = 0;		pd = 0;
			}  // for
if (test == "1") 		print("End of Vertical. CONTINUE ?");
			//-------- end -- vertical search -----------------
			for(k=0;k<c;k=k+1) {	dif[k]= pointB[k]-pointA[k];	}
			// ---------- max et moyenne de la difference -----------
			meandf = 0;
			for(k=0;k<c-1;k=k+1) {	meandf = meandf + dif[k];	
				if(dif[k]> max) 	max = dif[k];	
			} // for
if (test == "1") 		print("End of Vertical2. CONTINUE ?");
			meandf = meandf/c;
			Ratio = max/meandf;
			wait(50);
			run("Duplicate...", "title=vignetteB");
			selectImage(image);		close();
			// ------------- axe 1 ----------------------------
			run("Flip Horizontally");
			run("Image Calculator...", "image1=vignetteA operation=Difference image2=vignetteB create");
			selectImage("Result of vignetteA");
			getHistogram(0, hist, 256);
			areasym = hist[0];
			ratio1 = (areasym/2)/area;
			selectImage("Result of vignetteA");	close();
			// ------------- axe 2 ----------------------------
			selectImage("vignetteB");
			run("Make Binary");
			run("Flip Horizontally");
			selectImage("vignetteB");
			run("Flip Vertically");
			run("Image Calculator...", "image1=vignetteA operation=Difference image2=vignetteB create");
			selectImage("Result of vignetteA");
			//	run("Make Binary");
			getHistogram(0, hist, 256);
			areasym2 = hist[0];
			ratio2 = (areasym2/2)/area;
			ratioh = toString(ratio1);
			ratiov = toString(ratio2);
			// ------------------ Fermeture des vignettes -------------------------------------
			selectImage("Result of vignetteA");		close();
			selectImage("vignetteA");			close();
			selectImage("vignetteB");			close();
			if (isOpen("Results")) { selectWindow("Results");		run('Close');	}// if
			// ++++++++++++++++++++++++++
			symetrieh[totalvig] = 	ratio1;	
			symetriev[totalvig] = 	ratio2;	
			ratio[totalvig] = 		Ratio;	
			// ++++++++++++++++++++++++++
if (test == "1") 		print("End of Symetry1. CONTINUE ?");
	
			// ---------------- La vignette utilisee est nettoyee ------------------------------------------
			selectImage("vignette_msk");

			run("Set Measurements...",parametres2 );
			run("Measure");
			run("Select None");
			//-----------------------Recuperation des mesures complementaires a celles de la 1ere analyse-------------------
			updateResults();
			area_exc = 	getResult("Area", 0);
			mean = 		getResult("Mean", 0);
			stddev = 		getResult("StdDev", 0);
			mode = 		getResult("Mode", 0);
			min = 		getResult("Min", 0);
			max = 		getResult("Max", 0);
			x = 		getResult("X", 0);
			y = 		getResult("Y", 0);
			xm = 		getResult("XM", 0);
			ym = 		getResult("YM",0);
			perim = 		getResult("Perim.",0);
			bx = 		getResult("BX", 0);
			by = 		getResult("BY", 0);
			l = 		getResult("Width", 0);
			h = 		getResult("Height", 0);
			major = 		getResult("Major",0);
			minor = 		getResult("Minor", 0);
			angle = 		getResult("Angle",0);
			circ = 		getResult("Circ.", 0);
			feret = 		getResult("Feret", 0);
			intden = 		getResult("IntDen", 0);
			median = 	getResult("Median",0);
			skew = 		getResult("Skew", 0);
			kurt = 		getResult("Kurt", 0);
			Mean[totalvig]=		mean;
			StdDev[totalvig]=	stddev;
			Mode[totalvig]=		mode;
			Min[totalvig]=		min;
			Max[totalvig]=		max;
			X[totalvig]=		x;
			Y[totalvig]=		y;
			XM[totalvig]=		xm;
			YM[totalvig]=		ym;
			Perim[totalvig]=		perim;
			Major[totalvig]=		major;
			Minor[totalvig]=		minor;
			Angle[totalvig]=		angle;
			Circ[totalvig]=		circ;
			Feret[totalvig]=		feret;
			IntDen[totalvig]=	intden;
			Median[totalvig]=	median;
			Skew[totalvig]=		skew;
			Kurt[totalvig]=		kurt;
   			run("Clear Results");
	
	if (test == "1") 	print("End of grey measurements. CONTINUE ?");
			// ------------------------ Mesure de la pente et des parametres de l'histogramme des niveaux de gris --------------
			selectImage(titrered);
			run("Image Calculator...", "image1="+titrered+" operation=Add image2=vignette_msk");
       	     		//------------------------ convex perimeter calculation ----------------------------
          	   		selectImage("vignette_msk");
	     		run("Duplicate...","title=convexim");
          	 		run("Convex Hull esmer", "mode=[Draw Convex Hull]");
             	     	run("my Bin");
	 	    	run("Fill Holes");
	 	   	getHistogram(0, hist, 256);
	 	    	Convarea = hist[0];
			// +++++++++++++++++++++++++
		     	convarea[totalvig] = Convarea;
			// +++++++++++++++++++++++++
		     	run("Outline");
  		     	getHistogram(0, hist, 256);
		     	Convperim = hist[0];
		     	// ++++++++++++++++++++++++++
			convperim[totalvig] = Convperim;
		     	// ++++++++++++++++++++++++++
			selectImage("convexim");	     	close();
			selectImage(titrered);
			getHistogram(0, hist, 256);
			sumg = 0;	suma = 0;	hh = 0;		secartg = 0;	secarta = 0;
			// ----------------------- On ne prend pas les pixels à 255 ! -----------------------------------------
			Histcum = 	newArray(255);
			for (k=0; k<255; k++) {	sumg = sumg+hist[k];	Histcum[k] = sumg;		suma = suma+k;		} // for
			while (hh < 256) {	dat = Histcum[hh]/sumg;
			     	// ++++++++++++++++++++++++++
				if (dat < 0.25 ) Histcum1[totalvig] = hh;
				if (dat < 0.50 ) Histcum2[totalvig] = hh;
				if (dat < 0.75 ) Histcum3[totalvig] = hh;
				// ++++++++++++++++++++++++++	
				if (dat > 0.75) 	hh = 256;
				hh++;
			} // for
			moyenneg = sumg/255;	moyennea = suma/255;
			//---------Calcul de la pente de la regression  : stda/stdg -------------------
			for (t =0;t<255;t++) { 
				ecartgcar = pow(hist[t]-moyenneg,2);
				secartg = secartg+ecartgcar;
				ecartacar = pow(t-moyennea,2);
				secarta = secarta+ecartacar;
			} // for
			stdg = secartg*1/(255-1) ;
			stdg = pow(stdg,0.5);
			stda = secarta*1/(255-1) ;
			stda = pow(stda,0.5);
		     	// ++++++++++++++++++++++++++
			Slope[totalvig] = stdg/stda;
		     	// ++++++++++++++++++++++++++
			// --------------------- Contrast --------------------------------------------
            	      	S = newArray(256);
 			F = 0;                  	count = 1;
			// ------------- Correction seuils ----------------------------------
			AAA = 0;	BBB = 0;	CCC = 0;
			for (k=0; k<255; k++) {	data = hist[k];
				if (hist[k] !=0 && hist[k] < Histcum1[totalvig]) 		AAA = k;
				if (hist[k] !=0 && hist[k] < Histcum2[totalvig]) 		BBB = k;
				if (hist[k] !=0 && hist[k] < Histcum3[totalvig]) 		CCC = k;
			} // for
			selectImage(titrered);
            	         	for(x=1;x<l-1;x=x+1)	{
            	             		for(y=1;y<h-1;y=y+1)	{        		
					p = getPixel(x,y);
            	                   		if(p==AAA || p==BBB || p==CCC )	{	p1 = getPixel(x-1,y-1);
            	                       			p2 = getPixel(x-1,y);
            	                       			p3 = getPixel(x-1,y+1);
            	                       			p4 = getPixel(x,y-1);
            	                       			p5 = getPixel(x,y+1);
            	                      			p6 = getPixel(x+1,y-1);
            	                       			p7 = getPixel(x+1,y);
            	                       			p8 = getPixel(x+1,y+1);
            	                       			A= (p1+p2+p3+p4+p5+p6+p7+p8)/8;
            	                       			S[p]=S[p]+ abs(p-A);
            	                       			count = count + 1;
						F = F + S[p]*hist[p]/256;
            	            		} // if
		                      	} // for
			} // for
                 		Fcons = F/count;
			// ++++++++++++++++++++++++++
			fcons[totalvig] = Fcons;	
			// ++++++++++++++++++++++++++
if (test == "1") 		print("End of Slope. CONTINUE ?");
	
			// ------------------------ Calcul du nombre d'objets restant apres differents thresholds -----------------------------
			run("Set Measurements...", "area limit redirect=None decimal=0");
			// -------------- Mesure A ----------------------------
			selectImage(titrered);
			run("Duplicate...",titrered+"-1");
			setThreshold(0, Histcum1[totalvig]);
			run("Threshold", "thresholded remaining black");
			run("Erode");
			if (process_option == "C") {			saveAs("Tif",chemwork+titrered+"_"+i+"_A1");			rename(titrered+"-1");		} // if
	//		run("Analyze Particles...", "size=5-1095635 circularity=0.00-1.00 show=Nothing exclude include");
			run("Analyze Particles...", "size=1-1095635 circularity=0.00-1.00 show=Nothing include");
			updateResults();
			if (isOpen("Results")) { 
				// ++++++++++++++++++++++++++
				nbA[totalvig] = nResults;	
		     		// ++++++++++++++++++++++++++
				run("Clear Results");	
			} // if
	if (test == "1") 	print("End of mesureA. CONTINUE ?");
			selectImage(titrered+"-1");		close();
			// -------------- Mesure B ----------------------------
			selectImage(titrered);
			run("Duplicate...",titrered+"-1");
			setThreshold(0, Histcum2[totalvig]);
			run("Threshold", "thresholded remaining black");
			run("Erode");
	//		run("Analyze Particles...", "size=5-1095635 circularity=0.00-1.00 show=Nothing exclude include");
			run("Analyze Particles...", "size=1-1095635 circularity=0.00-1.00 show=Nothing include");
	
			updateResults();
			if (isOpen("Results")) { 
				// ++++++++++++++++++++++++++
				nbB[totalvig] = nResults;	
				// ++++++++++++++++++++++++++
				run("Clear Results");	
			} // if
	if (test == "1") 	print("End of mesureB. CONTINUE ?");
			selectImage(titrered+"-1");		close();
			// -------------- Mesure C et symétrie C ----------------------------
			selectImage(titrered);
			run("Duplicate...",titrered+"-1");
			// --------------- Correction de Histcum3 si aucun pixel de cette valeur -----------------------------------------
			threshold3 = Histcum3[totalvig];
			while (hist[threshold3]== 0) {data3 = Histcum3[totalvig]; 	Histcum3[totalvig] = data3+1;		threshold3 = Histcum3[totalvig];	} // while
			setThreshold(0, Histcum3[totalvig]);
			run("Threshold", "thresholded remaining black");
			// ------------------- symétrie brute ----------------------
			image = "vignettesym";
			selectImage(titrered+"-1");
			HH = 	getHeight();		WW = 	getWidth();
			if(isOpen("vignettesym")) { selectImage("vignettesym"); close();	} // if
			run("Duplicate...", "title=vignettesym");
if (test == "1") 		print("End of duplicateC. CONTINUE ?");
			// --------------- Agrandissement de l'image -------------------------
	//		newImage("vignetteag", "8-bit White",WW*1.2, HH*1.2, 1);
			selectImage("vignettesym");		
			largeursym = 	WW*1.2;
			hauteursym = 	HH*1.2;
			canvas = "width="+largeursym+" height="+hauteursym+" position=Center";
			run("Canvas Size...", canvas);
			run("Set Measurements...", "area centroid bounding fit redirect=["+image+"] decimal=2");
			run("Analyze Particles...", "size=0-Infinity circularity=0.00-1.00 show=Nothing include record");
			// ------------------ Symetrie du plus gros objet de la vignette ---------------------------
			updateResults();
if (test == "1") 		print("End of duplicateC2. CONTINUE ?");
			nbobj = nResults;
			ligne = 0;		g = 0;		Ratio = 0;
			// ---------------------- Si probleme de vignette blanche -----------------------------------
			if (nbobj == 0) {
				print(titrered+"  "+i+" " +Histcum3[totalvig]);
				selectImage(titrered);
				saveAs("Tif",chemwork+titrered+"_"+i+"_sympb");			
				rename(titrered);
				showMessage(titrered+"  "+i+" " +Histcum3[i]);
			} //
			areainit = getResult("Area", ligne);
			while (g<nbobj) {		area = getResult("Area", g);
				if (area > areainit) ligne = g;
				areainit = maxOf(area,areainit);
				g++;
			} // for
	
			if (areainit > 1) {
	if (test == "1") 		print("Area = "+areainit);	
				bx = 	getResult("BX", ligne);
				by = 	getResult("BY", ligne);
				w = 	getResult("Width", ligne);
				h = 	getResult("Height", ligne);
				x = 	getResult("X", ligne);
				y = 	getResult("Y", ligne);
				area = 	getResult("Area", ligne);
				major = 	getResult("Major", ligne);
				angle = 	getResult("Angle", ligne);
				xstart = 	getResult("XStart", ligne);
				ystart =	getResult("YStart", ligne);
				angle = 	angle +180;
				angle = 	toString(angle);

				// --------------- nettoyage autour du plus gros objet -------------
				selectImage(image);
				DEBX = xstart;
				DEBY= ystart;
				doWand(DEBX,DEBY);
				run("Clear Outside");

				// ---------------- centrage ----------------------
				sum = w*w + h*h;
				diag = pow(sum, 0.5);
				diag = diag * 1.2;	
				selectImage(image);
				rename("vignetteA");
				canvas = "width="+diag+" height="+diag+" position=Center";
				run("Canvas Size...", canvas);
				selectImage("vignetteA");
				run("Make Binary");
				run("Select None");
				rotation = "angle="+angle+" interpolate";
				rotation = "angle="+angle+" grid=1 fill";
				run("Arbitrarily...",rotation );
				run("Duplicate...", "title=vignetteB");
if (test == "1") 			print("End of centrage. CONTINUE ?");
	
				// ------------- axe 1 ----------------------------
				run("Flip Horizontally");
				run("Image Calculator...", "image1=vignetteA operation=Difference image2=vignetteB create");
				selectImage("Result of vignetteA");
				getHistogram(0, hist, 256);
				areasym = hist[0];
				ratio1 = (areasym/2)/area;
				selectImage("Result of vignetteA");		close();
if (test == "1") 		print("End of sym1. CONTINUE ?");
				// ------------- axe 2 ----------------------------
				selectImage("vignetteB");
				run("Make Binary");
				run("Flip Horizontally");
				selectImage("vignetteB");
				run("Flip Vertically");
				run("Image Calculator...", "image1=vignetteA operation=Difference image2=vignetteB create");
				selectImage("Result of vignetteA");
				//	run("Make Binary");
				getHistogram(0, hist, 256);
				areasym2 = hist[0];
				ratio2 = (areasym2/2)/area;
if (test == "1") 		print("End of sym2. CONTINUE ?");
				// ------------------ Fermeture des vignettes -------------------------------------
				selectImage("Result of vignetteA");		close();
				selectImage("vignetteA");			close();
				selectImage("vignetteB");			close();
				if (isOpen("Results")) { selectWindow("Results");		run('Close');	}
				// ++++++++++++++++++++++++++
				symetriehc[totalvig] = 	ratio1;	
				symetrievc[totalvig] = 	ratio2;	
				// ++++++++++++++++++++++++++
			} // if areainit
			selectImage(titrered+"-1");
			run("Erode");

if (test == "1") 		print("End of Symetry2. CONTINUE ?");
			run("Set Measurements...", "area limit redirect=None decimal=0");
//			run("Analyze Particles...", "size=5-1095635 circularity=0.00-1.00 show=Nothing exclude include");
			run("Analyze Particles...", "size=1-1095635 circularity=0.00-1.00 show=Nothing include");
			updateResults();
			if (isOpen("Results")) { 
				// ++++++++++++++++++++++++++
				nbC[totalvig] = nResults;	
				// ++++++++++++++++++++++++++
				run("Clear Results");	
			} // if
			selectImage(titrered+"-1");		close();
	
			// ------------------------ Fermeture de la vignette en niveaux de gris ----------------------------------------------------
			selectImage(titrered);	close();
	
			// --------------------- Position du barycentre pondere apres gamma = 5 -----------------------------------------------
			selectImage("vignette_msk");
//			run("Gamma...", "value=5");
if (test == "1") 		print("End of Gamma. CONTINUE ?");


//			selectImage("vignette_msk");
//			doWand(DEBX,DEBY);
//			run("Set Measurements...",parametres3);
//			run("Measure");
//			updateResults();
//			xmg5 = 		getResult("XM",0);
//			ymg5 = 		getResult("YM",0);
			// ++++++++++++++++++++++++++
//			XMg5[totalvig] =	xmg5;
//			YMg5[totalvig] = 	ymg5;
			// ++++++++++++++++++++++++++
// 			run("Clear Results");

if (test == "1") 	print("End of Gamma5. CONTINUE ?");
	
		// ------------------------ Fermeture de la vignette en niveaux de gris ----------------------------------------------------
		selectImage("vignette");	close();
		// -------------------------On agrandit l'image de facon a obtenir une posibilite d'agrandissement pour les contours ----------
		selectImage("vignette_msk");
		L = getWidth();		H = getHeight();
		makeRectangle(0,0,L,H);
		run("Copy");
		if (L >= 200 && H >= 200) { 	Lf = 2*L;	Hf = 2*H;		} // if
		else { 			Lf = 4*L;	Hf = 4*H;		} // else
		Xs = floor(Lf/2 - L/2);
		Ys = floor(Hf/2 - H/2);
		newImage("temp", "8-bit White", Lf, Hf, 1);
		makeRectangle(Xs,Ys, L, H);
		run("Paste");

		//--------------------------------Skeleton Area--------------------------------------------------
		selectImage("vignette_msk");
		run("Skeletonize");
		getHistogram(0, histS, 256);
		histo0 = histS[0];
		// ++++++++++++++++++++++++++
		Skelarea[totalvig] = histo0;
		// ++++++++++++++++++++++++++
		if (process_option == "C") {		selectImage("vignette_msk");		saveAs("Tif",chemwork+titrered+"_"+i+"_skeleton");		rename("vignette_msk");	} // if
		selectImage("vignette_msk");	close();
if (test == "1") 	print("End of Skeleton. CONTINUE ?");
		//--------------------------------Fractal analyse-------------------------------------------------
		selectImage("temp");
		if (process_option == "C") {		saveAs("Tif",chemwork+titrered+"_"+i+"_temp");		rename("temp");		} // if
		makeRectangle(0,0,Lf,Hf);
		run("Copy");
		selectImage("temp");	close();
		newImage("edm1", "8-bit White", Lf, Hf, 1);
		newImage("edm2", "8-bit White", Lf, Hf, 1);
		run("Paste");
  		selectImage("edm1");
		run("Paste");
  		run("Distance Map");
		if (process_option == "C") {		saveAs("Tif",chemwork+titrered+"_"+i+"_edm1");		rename("edm1");		} // if
  		selectImage("edm2");
  		run("Invert");
		run("Distance Map");
		run("Invert");
		if (process_option == "C") {		saveAs("Tif",chemwork+titrered+"_"+i+"_edm2");		rename("edm2");		} // if
		selectImage("edm1");
		run("Invert");
		run("Image Calculator...", "image1=edm1 operation=Add image2=edm2");
		selectImage("edm2");	close();
   		run("Clear Results");
  		selectImage("edm1");
  		run("Set Measurements...", "area limit decimal=3");
  		if (isOpen("Log")) {	selectWindow("Log");	run("Close"); 	} // if
  		lg = 0;  	counter=0;	iterations = 40;	sumg = 0;	suma = 0;	index = 0;
		Lg = newArray(iterations);
		Aire = newArray(iterations);
  		for (k=1; k<=iterations; k++) {	 y = round(pow(1.1, k));
   			if (lg!=y) {	lg = y;
  				selectImage("edm1");
      				setThreshold(0, lg);
   				run("Measure");
    				Lg[index] = log(2*lg);
				arr = getResult("Area", index);
				Aire[index] = log(arr);
				sumg = sumg+Lg[index];
				suma = suma+Aire[index];
				index++;
			} // if
  		} // for
		selectImage("edm1");	close();
		moyenneg = sumg/index;
		moyennea = suma/index;
		//---------Calcul de la pente de la regression  : stda/stdg -------------------
		secartg = 0;	secarta = 0;
		for (t =0;t<index;t++) { 
			ecartgcar = pow(Lg[t]-moyenneg,2);
			secartg = secartg+ecartgcar;
			ecartacar = pow(Aire[t]-moyennea,2);
			secarta = secarta+ecartacar;
		} // for
		stdg = secartg*1/(index-1) ;
		stdg = pow(stdg,0.5);
		stda = secarta*1/(index-1) ;
		stda = pow(stda,0.5);
		// ++++++++++++++++++++++++++
		Fractal[totalvig] = 2 - stda/stdg;
		// ++++++++++++++++++++++++++
if (test == "1") 	print("End of Fractal. CONTINUE ?");
		// --------------------- Gestion memoire --------------------------------------------------------------------
		if (i/1000 == floor(i/1000) ) {	p = i+1;		showStatus("Item  : "+p+" /"+nbblobs+"  => Release PC now ");	
			for (b=0;b<4;b++)	{	run("free memory");		wait(1000);	} // for	
		} // if
		// -------------- Increment du no de vignette ----------------------------------
		totalvig++;
		} // if   ------------------ Vignette existe et apres FIRSTIMGOK et inf a profmin  -------------------------
//		else {		showStatus("Skip vignette "+ i +"/"+listaff.length+"  WAIT !");		} // else

	}  // for i ---------------  boucle vignettes -----------------------------

	//====================  creer le tableau RESULTS =======================================================
	updateResults();
	selectWindow("Results");
	run("Close");
	//----------Mettre les bons resultats dans le tableau de nouveau------------------
	for (i=0; i<totalvig ; i++) {	
		setResult("Label", i,listaff[i]);
		//	setResult("NoImage", i,Vigimg[i]);
		setResult("Z",i,Depth[i]);
		setResult("Area",i,Area[i]);
		setResult("Mean",i,Mean[i]);
		setResult("StdDev",i,StdDev[i]);
		setResult("Mode",i,Mode[i]);
		setResult("Min",i,Min[i]);
		setResult("Max",i,Max[i]);
		setResult("X",i,X[i]);
		setResult("Y",i,Y[i]);
		setResult("XM",i,XM[i]);
		setResult("YM",i,YM[i]);
		setResult("Perim.",i,Perim[i]);
		setResult("BX", i, BX[i]);
		setResult("BY", i, BY[i]);
		setResult("Width", i, WIDTH[i]);
		setResult("Height", i,HEIGTH[i]);
		setResult("Major",i,Major[i]);
		setResult("Minor",i,Minor[i]);
		setResult("Angle",i,Angle[i]);
		setResult("Circ.",i,Circ[i]);
		setResult("Feret",i,Feret[i]);
		setResult("IntDen",i,IntDen[i]);
		setResult("Median",i,Median[i]);
		setResult("Skew",i,Skew[i]);
		setResult("Kurt",i,Kurt[i]);
		setResult("%Area", i, PArea[i]);
		setResult("XStart", i,XSTART[i]);
		setResult("YStart", i,YSTART[i]);
		setResult("Area_exc",i,Area_exc[i]);
		setResult("Fractal",i,Fractal[i]);
		setResult("Skelarea",i,Skelarea[i]);
		if (process_option != "B") {	
			setResult("Slope",i,Slope[i]);
			setResult("Histcum1",i,Histcum1[i]);
			setResult("Histcum2",i,Histcum2[i]);
			setResult("Histcum3",i,Histcum3[i]);
			setResult("XMg5",i,XMg5[i]);
			setResult("YMg5",i,YMg5[i]);
			setResult("Nb1",i,nbA[i]);
			setResult("Nb2",i,nbB[i]);
			setResult("Nb3",i,nbC[i]);
			setResult("Compentropy",i,compentropy[i]);
			setResult("Compmean",i,compmean[i]);
			setResult("Compslope",i,compslope[i]);
			setResult("CompM1",i,compm1[i]);
			setResult("CompM2",i,compm2[i]);
			setResult("CompM3",i,compm3[i]);
			setResult("Symetrieh",i,symetrieh[i]); 
			setResult("Symetriev",i,symetriev[i]); 
			setResult("Symetriehc",i,symetriehc[i]);
			setResult("Symetrievc",i,symetrievc[i]); 
			setResult("Convperim",i,convperim[i]);
			setResult("Convarea",i,convarea[i]); 
			setResult("Fcons",i,fcons[i]); 
			if (isNaN(ratio[i])) ratio[i] = 1;
			setResult("ThickR",i,ratio[i]); 
		} // if process_option
		// ---------- Ajout AREA au threshold I2s -------------------------------
 		if (process_option == "advancedi") 		setResult("Areai",i,Areai[i]);
	} // for
	setBatchMode(false);

	// -------------------- Enregistrement RESULTS ----------------------------------
	updateResults();
	selectWindow("Results");  	
	saveAs("measurements",pathprocessed+profile+"_measurements.txt");

	// --------------------- Lecture METADATA ---------------------------------------
	open(pathprocessed+profile+"_meta.txt");
	wait(100);
	config = getInfo();
	run("Close");
	conf  = split(config,"\n");
	field = conf[0];
	data = conf[1];
	field = replace(field,";"," ");
	data = replace(data,";"," ");
	field = split(field," ");
	data = split(data," ");
	size = field.length;

	// -------------------- ECRITURE PID -----------------------------------------------
	if (isOpen("Log")) {	selectWindow("Log");	run("Close"); 	} // if
	print("PID");
	print("[Metadata]");
	for (t=0;t<size;t++) {	print(field[t]+"= "+data[t]);	} // for
	print("[Camera_settings]");
	hdr_data = false;
	if (File.exists(hdr_file_work)) {
		open(hdr_file_work);
		wait(100);
		data = getInfo();
		run("Close");
		hdr_data = true;		
	}//
	else if (File.exists(hdr_file_raw)){
		File.rename(pathraw+profileraw +".hdr",pathraw+profileraw +".txt");
		open(hdr_file_raw);
		wait(100);
		data = getInfo();
		run("Close");	
		hdr_data = true;		
		File.rename(pathraw+profileraw +".txt",pathraw+profileraw +".hdr");		
	}
	else {	print("header_file= not_found");	} // else
	if (hdr_data == true ) {
		conf  = split(data,"\n");
		description = conf[1];
		if (lengthOf(description) >0) {
			long = lengthOf(description);
			description = substring(description,1,long);
			print("File_description= "+description);
		}
		for (i=1;i<conf.length;i++){
			file = conf[i];
			if (lengthOf(file) > 3) {
				if (startsWith(file,"TaskType="))	print(file);
				else if (startsWith(file,"DiskType=")) 	print(file);
				else if (startsWith(file,"Filesavetype="))print(file);
				else if (startsWith(file,"AVIFileSize=")) print(file);
				else if (startsWith(file,"AVISleep="))print(file);	
				else if (startsWith(file,"ShutterSpeed="))print(file);
				else if (startsWith(file,"ShutterMode="))print(file);
				else if (startsWith(file,"ShutterPolarity="))print(file);
				else if (startsWith(file,"Gain="))print(file);
				else if (startsWith(file,"Gamma="))print(file);
				else if (startsWith(file,"Threshold="))print(file);
				else if (startsWith(file,"TriggerMode=")) print(file);
				else if (startsWith(file,"Thresh="))print(file);
				else if (startsWith(file,"SMbase="))print(file);
				else if (startsWith(file,"SMzoo=")) print(file);
				else if (startsWith(file,"TimeOut="))print(file);
				else if (startsWith(file,"BRUoption=")) print(file);
				else if (startsWith(file,"EraseBorderBlobs="))print(file);
				else if (startsWith(file,"Choice=")) print(file);
				else if (startsWith(file,"Ratio="))print(file);
				else if (startsWith(file,"N="))print(file);
				else if (startsWith(file,"DataMoy=")) print(file);
				else if (startsWith(file,"FontPath="))print(file);
				else if (startsWith(file,"FontSubstract="))print(file);
				else if (startsWith(file,"SaveAfterSub=")) print(file);
			} // if length
		} // for
	} //if	
	print("[Process]");
	print("pressure_gain= "+pressure_gain);
	print("calibration= "+calibration);
	print("pixel= "+pixel);
	print("upper= "+upper);	
	print("gamma= "+gamma);
	print("echelle_mm= "+echelle_mm);
	print("process_option= "+process_option);
	print("profmin= "+profmin);
	print("esdmin= "+esdmin);
	print("esdmax= "+esdmax);
	print("Spmin= "+Spmin);
	print("Spmax= "+Spmax );
	if (flagimg == 1) print("processsource= raw_images");
	if (flagimg == 0) print("processsource= raw_vignettes");
	print("Background_cleaning= "+clean);
	print("Background_adjust= "+back);
	dateheure =	runMacro("Zooscan_get_time_5");
	print("Parametre_2= "+parametres2);
	print("Parametre_3= "+parametres3);
	print("Date= ",dateheure);
	print("First_image= "+firstimg);
	print("First_image_name= "+image0text);
	print("Total_processed_object= "+totalvig);
	print("Last_image= "+endimg);
	print("Last_image_name= "+image_end_text);
	if (totalvig == 0) {	aa = getBoolean("WARNING : \n \nNo object could be detected for "+profile+" \n \nCheck acquisition & process settings ! \n \nPRESS YES to continue process for next profile (PID file of this profile will not contain any DATA)!\nPress CANCEL to process next profile (No PID file saved for this profile !)");		}// if
	totalvig = toString(totalvig);
	argpid = "UVP5 "+totalvig+" "+TAG+" "+titrered;
	if (process_option == "advancedi") argpid = "UVP5i "+totalvig+" "+TAG+" "+titrered;
	argpid = 		runMacro("Zooscan_print_pid_5",argpid);
	flag =		toString(argpid);
	l= 		lengthOf(flag);
	if (l==1)  { getBoolean("Error message : Print_pid_5 process aborted !    \n \nPress Cancel to abort !                   "); } // if
	selectWindow("Log");	
	// ---------------- Enregistrement dans le repertoire du profile -------------
	sauvepid = "save=" + pathprocessed+profile +"_dat1.pid";			
	run("Text...",sauvepid);
	// ----------------- Enregistrement dans pid_results de la mission ---------
	sauvepid = "save=" + pathpidresults+profile +"_dat1.pid";			
	run("Text...",sauvepid);
} // process vignettes PID
if (isOpen("Results") ) {	selectWindow("Results");  	run("Close");		} // if
// ----------------------------- FIN ----------------------------------------------
ret = "OK";
return ret;
