// -------------------------- UVP5_process_vignette_PID --------------------------
version = "1.03";
date = "2009/07/19";

args = getArgument();
arg = split(args, " ");
dirprocessed = arg[0];
datfilename = arg[1];
profile = arg[2];
firstimg = arg[3];
firstimg = parseInt(firstimg);
processvignettes = arg[4];
processpid = arg[5];
dirprofile = arg[6];
dircruise = arg[7];

dirpid = dircruise + "\\PID_process\\pid_results\\";
if (File.exists(dirpid) == 0) File.makeDirectory(dirpid);

dirpred = dircruise + "\\PID_process\\prediction\\";
if (File.exists(dirpred) == 0) File.makeDirectory(dirpred);

print("A purger");
selectWindow("Log");
run("Close");
run("Colors...", "foreground=black background=white selection=red");

// -------------------- Mode TEST ---------------------------------------
test = "0";
if (test == "1") {
    batch = "false";
    getBoolean("MODE TEST ! Continue ?");
} // if

// ----------------- Parametres ----------------------
longline = 64;
gamma = "value=4.000"; // precedement a 3 jusqu'au 2/10/2008
echelle = "5 mm ";
voxelwidth = 1;
voxelheigth = 1;
voxeldepth = 1;
voxelunit = "pixel";
upper = 252;
option = "A";
param = "1";
TAG = 0;
batch = true;
profmax = 0.5;
//	profmax = 31.0;

// ----------------------- Pixel size ---------------------
pixel = 0.174;
Spmin = 20;
Spmax = 100000;

//------------- Ouverture du fichier  DAT reduit dans le repertoire final du profil ----------------
open(dirprocessed + datfilename);
wait(100);
data = getInfo();
wait(100);
run("Close");
ligne = split(data, "\n");

//	getBoolean(datfilename);

// -------------- Liste des fichiers BMP -----------------------------------
filelist = getFileList(dirprofile);
j = 0;
pos = 0;
flag = 0;
list = newArray(filelist.length);
for (i = 0; i < filelist.length; i++) {
    nomvig = filelist[i];
    path = dirprofile + "\\" + nomvig;
    size = File.length(path);
    size = parseInt(size);
    pos = endsWith(nomvig, ".bmp");
    if (pos == true) {
        rr = filelist[i];
        list[j] = rr;
        j++;
    } // if
    if (pos == true && size == 1311798) flag = 1;
} // for
if (j >= 1) {
    listaff = newArray(j);
    for (i = 0; i < listaff.length; i++) {
        rr = list[i];
        listaff[i] = rr;
    } // for
} // if

// ---------------- liste des images pour lesquelles une vignette existe Indexation profondeur -------------------------
vignumber = 0;
nn = 5 * j; // Par precaution, car on a enleve des vignettes en surface !
Vigname = newArray(nn);
Vigdepth = newArray(nn);
Vigimg = newArray(nn);

for (i = 0; i < ligne.length; i++) {
    dataline = ligne[i];
    dataline = replace(dataline, ";", " ");
    dataline = split(dataline, "\ ");
    noimg = dataline[0];
    noimg = parseInt(noimg);
    vigname = dataline[1]; // Nom image source
    vigdepth = dataline[2]; // Immersion
    vignb = dataline[17]; // Nombre de vignettes dans l'image
    vignb = parseInt(vignb);
    // --------------- Nom de la premiere image a conserver ------------------
    if (noimg == firstimg) {
        image0 = substring(vigname, 0, 14);
    } // if
    if (vignb != 0) {
        for (m = 0; m < vignb; m++) {
            Vigname[vignumber] = vigname; // Nom image source
            vigdepth = parseFloat(vigdepth); // Immersion
            Vigdepth[vignumber] = vigdepth / 10;
            Vigimg[vignumber] = noimg; // Nï¿½ de l'image dans le datfile
            vignumber++;
        } // for
    } // if
} // for

//	getBoolean("CONTINUE ?    "+dirprofile+"          ");

//	getBoolean("vignumber= "+vignumber+"    nbvignettes= "+j);
// ----------- detection VIGNETTE / IMAGE entiere -------------------------
if (flag == 1) {
    //	getBoolean("Full images have been saved. \nDo you want to process them or Cancel ? ");
    // -------------------- Process images entieres -----------------------------
    ret = runMacro("UVP5_vignettes_from_image", args);
    flag = toString(ret);
    l = lengthOf(flag);
    if (l == 1) {
        getBoolean("Image to vignette process aborted. \nPress Cancel to abort !    ");
    } // if
} // if


// -------------- Liste des vignettes -----------------------------------
filelist = getFileList(dirprofile);
j = 0;
pos = 0;
list = newArray(filelist.length);
for (i = 0; i < filelist.length; i++) {
    nomvig = filelist[i];
    pos = endsWith(nomvig, ".bmp");
    path = dirprofile + "\\" + nomvig;
    size = File.length(path);
    size = parseInt(size);
    //	showMessage(nomvig+"        "+size);	
    if (pos == true && size < 1311798) {
        rr = filelist[i];
        list[j] = rr;
        j++;
    } // if
} // for
if (j >= 1) {
    listaff = newArray(j);
    for (i = 0; i < listaff.length; i++) {
        rr = list[i];
        listaff[i] = rr;
    } // for
} // if

// --------------- Process PID vignette par vignette ---------------------

if (processpid == 1) {
    // -------------- Vecteurs -------------------------------
    nbblobs = j;
    Img = newArray(nbblobs);
    XSTART = newArray(nbblobs);
    YSTART = newArray(nbblobs);
    BX = newArray(nbblobs);
    BY = newArray(nbblobs);
    WIDTH = newArray(nbblobs);
    HEIGTH = newArray(nbblobs);
    Area = newArray(nbblobs);
    Mean = newArray(nbblobs);
    StdDev = newArray(nbblobs);
    Mode = newArray(nbblobs);
    Min = newArray(nbblobs);
    Max = newArray(nbblobs);
    X = newArray(nbblobs);
    Y = newArray(nbblobs);
    XM = newArray(nbblobs);
    YM = newArray(nbblobs);
    Perim = newArray(nbblobs);
    Major = newArray(nbblobs);
    Minor = newArray(nbblobs);
    Angle = newArray(nbblobs);
    Circ = newArray(nbblobs);
    Feret = newArray(nbblobs);
    IntDen = newArray(nbblobs);
    Median = newArray(nbblobs);
    Skew = newArray(nbblobs);
    Kurt = newArray(nbblobs);
    PArea = newArray(nbblobs);
    Area_exc = newArray(nbblobs);
    Fractal = newArray(nbblobs);
    Skelarea = newArray(nbblobs);

    Slope = newArray(nbblobs);
    Histcum1 = newArray(nbblobs);
    Histcum2 = newArray(nbblobs);
    Histcum3 = newArray(nbblobs);
    XMg5 = newArray(nbblobs);
    YMg5 = newArray(nbblobs);
    nbA = newArray(nbblobs);
    nbB = newArray(nbblobs);
    nbC = newArray(nbblobs);
    compentropy = newArray(nbblobs);
    compmean = newArray(nbblobs);
    compslope = newArray(nbblobs);
    compm1 = newArray(nbblobs);
    compm2 = newArray(nbblobs);
    compm3 = newArray(nbblobs);
    symetrieh = newArray(nbblobs);
    symetriev = newArray(nbblobs);
    symetriehc = newArray(nbblobs);
    symetrievc = newArray(nbblobs);
    convperim = newArray(nbblobs);
    convarea = newArray(nbblobs);
    fcons = newArray(nbblobs);
    ratio = newArray(nbblobs);
    Depth = newArray(nbblobs);

    // -------------------- BOUCLE PRINCIPALE sur les vignettes ------------------------------------------------------------------------------------
    setBatchMode(batch);
    totalvig = 0;
    for (i = 0; i < listaff.length; i++) {
        //	for (i=0; i<800 ; i++) {
        image = listaff[i];
        path = dirprofile + "\\" + image;
        // ------------ Recherche de la profondeur -------------
        vignette = substring(image, 0, 18);
        depth = 0;
        flag = 0;
        for (index = 0; index < vignumber; index++) {
            vig = Vigname[index]; //  Nom image source
            vig = replace(vig, "_", ".");
            vignette = replace(vignette, "_", ".");
            vig = parseFloat(vig);
            vignette = parseFloat(vignette); // Nom Image source (valide pour plusieurs vignettes)
            if (vig == vignette) {
                depth = Vigdepth[index];
            } // if
        } // for
        // ---------------- Nom vignette ---------------------------------
        vignette = substring(image, 0, 23);

        // ----------------- TEST premiere image ---------------------
        facteuri = 1;
        image0 = parseInt(image0);
        if ((image0 / 20000000000000) < 1) {
            facteuri = 10;
        } // if
        image0date = image0 * facteuri;

        facteurv = 1;
        vignettedate = substring(vignette, 0, 14);
        vignettedate = parseInt(vignettedate);
        if ((vignettedate / 20000000000000) < 1) {
            facteurv = 10;
        } // if
        vignettedate = vignettedate * facteurv;

        showStatus("Skip vignette " + i + "/" + listaff.length + "  WAIT !");
        profimg = parseFloat(depth);


        //	getBoolean(path);
        // ------------------ Vignette existe et apres FIRSTIMGOK et inf a profmax  -------------------------
        if (File.exists(path) && vignettedate >= image0date && profimg >= profmax) {
            profmax = maxOf(profimg, profmax);
            //	getBoolean("   image0= "+image0+"   image0dat = "+image0date+" facteuri="+facteuri+"    vignette= "+vignette+"    vignettedate= "+vignettedate+" facteurv="+facteurv);			
            // +++++++++++++++++++++
            Depth[totalvig] = depth;
            // +++++++++++++++++++++
            //	depth = parseInt(depth);
            //	depth = toString(depth);
            //	if (lengthOf(depth) == 1) depth = "000"+depth;
            //	if (lengthOf(depth) == 2) depth = "00"+depth;
            //	if (lengthOf(depth) == 3) depth = "0"+depth;

            //	titrered = profile+"_pid_"+depth+"_"+vignette;
            titrered = profile;

            // --------------- Ouverture vignette -----------
            if (test == "1") print("NEW vignette    " + i);
            open(path);

            if (test == "2") saveAs("bmp", path);

            rename(titrered);

            HH = getHeight();
            WW = getWidth();
            // --------- Inversion ------------------------------
            run("Invert");
            // -------------- Sauvegarde vignette -----------------------------------------------------
            if (processvignettes == 1) {
                run("Duplicate...", "title=vignette to save");
                // --------- Gamma -------------------------------
                run("Gamma...", gamma);
                // --------- Resize --------------------------------
                Wfinal = WW * 2;
                Hfinal = HH * 2;
                text = "width=" + Wfinal + " height=" + Hfinal + " constrain interpolate";
                run("Size...", text);
                // -------- Ajout de l'echelle 5 mm -----------------------------
                setLineWidth(2);
                setFont("SansSerif", 9);
                Wfinal = maxOf(Wfinal, longline + 30);
                H = Hfinal + 31;
                text = "width=" + Wfinal + " height=" + H + " position=Top-Left";
                run("Canvas Size...", text);
                drawString(echelle, 25, Hfinal + 10);
                drawLine(10, Hfinal + 10, 10 + longline, Hfinal + 10);
                drawLine(10, Hfinal + 10, 10, Hfinal + 7);
                drawLine(10 + longline, Hfinal + 10, 10 + longline, Hfinal + 7);
                drawString(profile, 10, Hfinal + 21);
                //			drawString(vignette,10,Hfinal+21);
                vignette = substring(image, 0, 23);
                depth = parseFloat(depth);
                depth = toString(depth);
                //	if (lengthOf(depth) == 1) depth = "000"+depth;
                //	if (lengthOf(depth) == 2) depth = "00"+depth;
                //	if (lengthOf(depth) == 3) depth = "0"+depth;
                Imagenb = Vigimg[i];
                Imagenb = toString(Imagenb);
                drawString(Imagenb + "   " + depth + " m", 10, Hfinal + 30);
                // -------- Enregistrement et fermeture ---------------
                norecord = totalvig + 1;
                saveAs("jpg", dirprocessed + titrered + "_" + norecord + ".jpg");
                //	showMessage(dirprocessed+titrered+"_"+index+".jpg"); 
                close();
            } // if
            selectImage(titrered);
            // +++++++++++++++++++++
            listaff[totalvig] = titrered;
            // +++++++++++++++++++++
            image = titrered;
            setVoxelSize(voxelwidth, voxelheigth, voxeldepth, voxelunit);
            run("Duplicate...", "title=vignette");
            run("Duplicate...", "title=vignette_msk");
            run("8-bit");
            setVoxelSize(1, 1, 1, voxelunit);
            setThreshold(0, upper);
            run("Threshold", "thresholded remaining black");
            if (isOpen("Results")) {
                selectWindow("Results");
                run('Close');
            }

            // ---------------------- Nettoyage de la vignette "vignette_msk" et premieres mesures -----------------------------------
            run("Set Measurements...", "area centroid center bounding area_fraction fit limit redirect=[vignette_msk] decimal=2");
            //	analysis1 =  "size=0-Infinity circularity=0.00-1.00 bins=20 show=Nothing include exclude flood record";
            analysis1 = "size=1-Infinity circularity=0.00-1.00 bins=20 show=Nothing include flood record";
            run("Analyze Particles...", analysis1);
            updateResults();
            nbobj = nResults;
            ligne = 0;
            g = 0;
            // ---------------------- Recherche plus gros -----------------------------------
            if (nbobj == 0) {
                print("Error : " + titrered + "  " + i);
                getBoolean("Error " + titrered + "  " + i);
            } // if
            areainit = 0;
            while (g < nbobj) {
                area = getResult("Area", g);
                bx = getResult("BX", g);
                by = getResult("BY", g);
                w = getResult("Width", g);
                h = getResult("Height", g);
                x = getResult("X", g);
                y = getResult("Y", g);
                //			if (bx != 0 && by != 0 && h != 0 && x != 0 && y != 0 ) {
                if (h != 0 && x != 0 && y != 0) {
                    if (area > areainit) {
                        ligne = g;
                        if (test == "1") print("1    bx =  " + bx + "   by = " + by + "   h = " + h + "   x = " + x + "   y = " + y + "    CONTINUE ?");
                    } // if
                    areainit = maxOf(area, areainit);
                } // if	
                g++;
            } // for
            bx = getResult("BX", ligne);
            by = getResult("BY", ligne);
            w = getResult("Width", ligne);
            h = getResult("Height", ligne);
            x = getResult("X", ligne);
            y = getResult("Y", ligne);
            area = getResult("Area", ligne);
            major = getResult("Major", ligne);
            angle = getResult("Angle", ligne);
            xstart = getResult("XStart", ligne);
            ystart = getResult("YStart", ligne);
            parea = getResult("%Area", ligne);
            // ++++++++++++++++++++++++++
            Area[totalvig] = area;
            PArea[totalvig] = parea;
            Area_exc[totalvig] = area - area * (0.01 * parea);
            BX[totalvig] = bx;
            BY[totalvig] = by;
            WIDTH[totalvig] = w;
            HEIGTH[totalvig] = h;
            XSTART[totalvig] = xstart;
            YSTART[totalvig] = ystart;
            // ++++++++++++++++++++++++++
            //	print("Image = "+i);
            // --------------- nettoyage autour du plus gros objet -------------
            selectImage("vignette_msk");
            if (test == "1") print("2    Area =  " + area + "   xstart = " + xstart + "   ystart = " + ystart + "    CONTINUE ?");
            DEBX = xstart;
            DEBY = ystart;
            doWand(DEBX, DEBY);
            run("Clear Outside");
            if (test == "1") print("3    End of CLEAR outside. CONTINUE ?");

            // ------------------- symï¿½trie brute et Ratio  ----------------------	
            image = "vignettesym";
            selectImage("vignette_msk");
            if (isOpen("vignettesym")) {
                selectImage("vignettesym");
                close();
            } // if
            run("Duplicate...", "title=vignettesym");
            if (isOpen("Results")) {
                selectWindow("Results");
                run('Close');
            }
            // --------------- Agrandissement de l'image -------------------------
            largeursym = WW * 1.2;
            hauteursym = HH * 1.2;
            canvas = "width=" + largeursym + " height=" + hauteursym + " position=Center";
            selectImage("vignettesym");
            run("Canvas Size...", canvas);

            // ----------------------- Nettoyage vignette "vignette_sym" -------------------------------
            if (test == "1") print("10    End of Agrandissement. CONTINUE ?");
            if (isOpen("Results")) {
                selectWindow("Results");
                run('Close');
            }
            run("Set Measurements...", "area centroid bounding fit redirect=[vignettesym] decimal=2");
            selectImage("vignettesym");
            run("Analyze Particles...", "size=0-Infinity circularity=0.00-1.00 show=Nothing include record");
            // ------------------ Symetrie du plus gros objet de la vignette ---------------------------
            if (test == "1") print("Debut Symetrie. CONTINUE ?");
            updateResults();
            nbobj = nResults;
            ligne = 0;
            g = 0;
            Ratio = 0;
            if (nbobj == 0) {
                print("Error Debut Symetrie : " + titrered + "  " + i);
                setBatchMode("exit and display");
                getBoolean("Error Debut Symetrie : " + titrered + "  " + i);
            } // if

            //		areainit = getResult("Area", ligne);
            areainit = 0;
            while (g < nbobj) {
                area = getResult("Area", g);
                bx = getResult("BX", g);
                by = getResult("BY", g);
                w = getResult("Width", g);
                h = getResult("Height", g);
                x = getResult("X", g);
                y = getResult("Y", g);
                //			if (bx != 0 && by != 0 && h != 0 && x != 0 && y != 0 ) {
                if (h != 0 && x != 0 && y != 0) {
                    if (area > areainit) {
                        ligne = g;
                        if (test == "1") print("bx =  " + bx + "   by = " + by + "   h = " + h + "   x = " + x + "   y = " + y + "    CONTINUE ?");
                    } // if
                    areainit = maxOf(area, areainit);
                } // if	
                g++;
            } // for
            bx = getResult("BX", ligne);
            by = getResult("BY", ligne);
            w = getResult("Width", ligne);
            h = getResult("Height", ligne);
            x = getResult("X", ligne);
            y = getResult("Y", ligne);
            area = getResult("Area", ligne);
            major = getResult("Major", ligne);
            angle = getResult("Angle", ligne);
            xstart = getResult("XStart", ligne);
            ystart = getResult("YStart", ligne);
            angle = angle + 180;
            angle = toString(angle);
            // --------------- nettoyage autour du plus gros objet -------------
            selectImage("vignettesym");
            DEBX = xstart;
            DEBY = ystart;
            doWand(DEBX, DEBY);
            run("Clear Outside");
            // ---------------- centrage ----------------------
            sum = w * w + h * h;
            diag = pow(sum, 0.5);
            diag = diag * 1.2;
            makeRectangle(bx, by, w, h);
            run("Copy");
            newImage("vignetteA", "8-bit White", diag, diag, 1);
            x = x - bx;
            y = y - by;
            posx = (diag / 2) - x;
            posy = (diag / 2) - y;
            makeRectangle(posx, posy, w, h);
            run("Paste");
            selectImage("vignetteA");
            run("Make Binary");
            run("Select None");
            rotation = "angle=" + angle + " interpolate";
            rotation = "angle=" + angle + " grid=1 fill";
            run("Arbitrarily...", rotation);


            //---------------- Vignette A est horizontale sur son grand axe -------------------
            W = diag;
            H = diag;
            getHistogram(0, hist, 256);
            if (test == "1") print("End of Histogram. CONTINUE ?");
            S = newArray(250);
            F = 0;
            pa = 0;
            pb = 0;
            pd = 0;
            flag = 0;
            max = 0;
            min = 1000;
            c = 0;
            count = 1;
            // ---------  Normalisation de l'intervalle par la taille pixel --------------
            step = floor(0.1 / pixel);
            step = maxOf(step, 1);
            pointA = newArray(1 + W / step);
            pointB = newArray(1 + W / step);
            dif = newArray(1 + W / step);
            if (test == "1") print("End of Array. CONTINUE ?");
            //-------- start--vertical search---------------
            for (x = 0; x < W; x = x + step) {
                for (y = 0; y < H - 1; y = y + 1) {
                    pa = getPixel(x, y);
                    pb = getPixel(x, y + 1);
                    pd = abs(pa - pb);
                    if (pd > 100 && flag == 0) {
                        flag = 1;
                        pd = 0;
                        pointA[c] = y;
                    } // if
                    if (pd > 100 && flag == 1) {
                        pointB[c] = y;
                        flag = 3;
                        c++;
                    } // if
                } // for
                flag = 0;
                pd = 0;
            } // for
            if (test == "1") print("End of Vertical. CONTINUE ?");
            //-------- end -- vertical search -----------------
            for (k = 0; k < c; k = k + 1) {
                dif[k] = pointB[k] - pointA[k];
            }
            // ---------- max et moyenne de la difference -----------
            meandif = 0;
            for (k = 0; k < c - 1; k = k + 1) {
                meandf = meandf + dif[k];
                if (dif[k] > max) max = dif[k];
            } // for
            if (test == "1") print("End of Vertical2. CONTINUE ?");
            meandf = meandf / c;
            Ratio = max / meandf;
            wait(50);
            run("Duplicate...", "title=vignetteB");
            selectImage(image);
            close();
            // ------------- axe 1 ----------------------------
            run("Flip Horizontally");
            run("Image Calculator...", "image1=vignetteA operation=Difference image2=vignetteB create");
            selectImage("Result of vignetteA");
            getHistogram(0, hist, 256);
            areasym = hist[0];
            ratio1 = (areasym / 2) / area;
            selectImage("Result of vignetteA");
            close();
            // ------------- axe 2 ----------------------------
            selectImage("vignetteB");
            run("Make Binary");
            run("Flip Horizontally");
            selectImage("vignetteB");
            run("Flip Vertically");
            run("Image Calculator...", "image1=vignetteA operation=Difference image2=vignetteB create");
            selectImage("Result of vignetteA");
            //	run("Make Binary");
            getHistogram(0, hist, 256);
            areasym2 = hist[0];
            ratio2 = (areasym2 / 2) / area;
            ratioh = toString(ratio1);
            ratiov = toString(ratio2);
            // ------------------ Fermeture des vignettes -------------------------------------
            selectImage("Result of vignetteA");
            close();
            selectImage("vignetteA");
            close();
            selectImage("vignetteB");
            close();
            if (isOpen("Results")) {
                selectWindow("Results");
                run('Close');
            } // if
            // ++++++++++++++++++++++++++
            symetrieh[totalvig] = ratio1;
            symetriev[totalvig] = ratio2;
            ratio[totalvig] = Ratio;
            // ++++++++++++++++++++++++++
            if (test == "1") print("End of Symetry1. CONTINUE ?");

            // ---------------- La vignette utilisee est nettoyee ------------------------------------------
            selectImage("vignette_msk");

            // ------------------- Mesures principales en niveaux de gris -----------------------------------------
            parametres2 = "area mean standard modal min centroid center perimeter bounding fit circularity feret's integrated median skewness kurtosis area_fraction limit redirect=" + titrered + " decimal=2";
            parametres3 = "centroid center redirect=vignette decimal=2";

            run("Set Measurements...", parametres2);
            run("Measure");
            run("Select None");
            //-----------------------Recuperation des mesures complementaires a celles de la 1ere analyse-------------------
            updateResults();
            area_exc = getResult("Area", 0);
            mean = getResult("Mean", 0);
            stddev = getResult("StdDev", 0);
            mode = getResult("Mode", 0);
            min = getResult("Min", 0);
            max = getResult("Max", 0);
            x = getResult("X", 0);
            y = getResult("Y", 0);
            xm = getResult("XM", 0);
            ym = getResult("YM", 0);
            perim = getResult("Perim.", 0);
            bx = getResult("BX", 0);
            by = getResult("BY", 0);
            l = getResult("Width", 0);
            h = getResult("Height", 0);
            major = getResult("Major", 0);
            minor = getResult("Minor", 0);
            angle = getResult("Angle", 0);
            circ = getResult("Circ.", 0);
            feret = getResult("Feret", 0);
            intden = getResult("IntDen", 0);
            median = getResult("Median", 0);
            skew = getResult("Skew", 0);
            kurt = getResult("Kurt", 0);
            Mean[totalvig] = mean;
            StdDev[totalvig] = stddev;
            Mode[totalvig] = mode;
            Min[totalvig] = min;
            Max[totalvig] = max;
            X[totalvig] = x;
            Y[totalvig] = y;
            XM[totalvig] = xm;
            YM[totalvig] = ym;
            Perim[totalvig] = perim;
            Major[totalvig] = major;
            Minor[totalvig] = minor;
            Angle[totalvig] = angle;
            Circ[totalvig] = circ;
            Feret[totalvig] = feret;
            IntDen[totalvig] = intden;
            Median[totalvig] = median;
            Skew[totalvig] = skew;
            Kurt[totalvig] = kurt;
            run("Clear Results");

            if (test == "1") print("End of grey measurements. CONTINUE ?");
            // ------------------------ Mesure de la pente et des parametres de l'histogramme des niveaux de gris --------------
            selectImage(titrered);
            run("Image Calculator...", "image1=" + titrered + " operation=Add image2=vignette_msk");
            //------------------------ convex perimeter calculation ----------------------------
            selectImage("vignette_msk");
            run("Duplicate...", "title=convexim");
            run("Convex Hull esmer", "mode=[Draw Convex Hull]");
            run("my Bin");
            run("Fill Holes");
            getHistogram(0, hist, 256);
            Convarea = hist[0];
            // +++++++++++++++++++++++++
            convarea[totalvig] = Convarea;
            // +++++++++++++++++++++++++
            run("Outline");
            getHistogram(0, hist, 256);
            Convperim = hist[0];
            // ++++++++++++++++++++++++++
            convperim[totalvig] = Convperim;
            // ++++++++++++++++++++++++++
            selectImage("convexim");
            close();
            selectImage(titrered);
            getHistogram(0, hist, 256);
            sumg = 0;
            suma = 0;
            hh = 0;
            secartg = 0;
            secarta = 0;
            // ----------------------- On ne prend pas les pixels ï¿½ 255 ! -----------------------------------------
            Histcum = newArray(255);
            for (k = 0; k < 255; k++) {
                sumg = sumg + hist[k];
                Histcum[k] = sumg;
                suma = suma + k;
            } // for
            while (hh < 256) {
                dat = Histcum[hh] / sumg;
                // ++++++++++++++++++++++++++
                if (dat < 0.25) Histcum1[totalvig] = hh;
                if (dat < 0.50) Histcum2[totalvig] = hh;
                if (dat < 0.75) Histcum3[totalvig] = hh;
                // ++++++++++++++++++++++++++	
                if (dat > 0.75) hh = 256;
                hh++;
            } // for
            moyenneg = sumg / 255;
            moyennea = suma / 255;
            //---------Calcul de la pente de la regression  : stda/stdg -------------------
            for (t = 0; t < 255; t++) {
                ecartgcar = pow(hist[t] - moyenneg, 2);
                secartg = secartg + ecartgcar;
                ecartacar = pow(t - moyennea, 2);
                secarta = secarta + ecartacar;
            } // for
            stdg = secartg * 1 / (255 - 1);
            stdg = pow(stdg, 0.5);
            stda = secarta * 1 / (255 - 1);
            stda = pow(stda, 0.5);
            // ++++++++++++++++++++++++++
            Slope[totalvig] = stdg / stda;
            // ++++++++++++++++++++++++++
            // --------------------- Contrast --------------------------------------------
            S = newArray(256);
            F = 0;
            count = 1;
            // ------------- Correction seuils ----------------------------------
            AAA = 0;
            BBB = 0;
            CCC = 0;
            for (k = 0; k < 255; k++) {
                data = hist[k];
                if (hist[k] != 0 && hist[k] < Histcum1[totalvig]) AAA = k;
                if (hist[k] != 0 && hist[k] < Histcum2[totalvig]) BBB = k;
                if (hist[k] != 0 && hist[k] < Histcum3[totalvig]) CCC = k;
            } // for
            selectImage(titrered);
            for (x = 1; x < l - 1; x = x + 1) {
                for (y = 1; y < h - 1; y = y + 1) {
                    p = getPixel(x, y);
                    if (p == AAA || p == BBB || p == CCC) {
                        p1 = getPixel(x - 1, y - 1);
                        p2 = getPixel(x - 1, y);
                        p3 = getPixel(x - 1, y + 1);
                        p4 = getPixel(x, y - 1);
                        p5 = getPixel(x, y + 1);
                        p6 = getPixel(x + 1, y - 1);
                        p7 = getPixel(x + 1, y);
                        p8 = getPixel(x + 1, y + 1);
                        A = (p1 + p2 + p3 + p4 + p5 + p6 + p7 + p8) / 8;
                        S[p] = S[p] + abs(p - A);
                        count = count + 1;
                        F = F + S[p] * hist[p] / 256;
                    } // if
                } // for
            } // for
            Fcons = F / count;
            // ++++++++++++++++++++++++++
            fcons[totalvig] = Fcons;
            // ++++++++++++++++++++++++++
            if (test == "1") print("End of Slope. CONTINUE ?");

            // ------------------------ Calcul du nombre d'objets restant apres differents thresholds -----------------------------
            run("Set Measurements...", "area limit redirect=None decimal=0");
            // -------------- Mesure A ----------------------------
            selectImage(titrered);
            run("Duplicate...", titrered + "-1");
            setThreshold(0, Histcum1[totalvig]);
            run("Threshold", "thresholded remaining black");
            run("Erode");
            if (option == "C") {
                saveAs("Tif", chemwork + titrered + "_" + i + "_A1");
                rename(titrered + "-1");
            } // if
            //		run("Analyze Particles...", "size=5-1095635 circularity=0.00-1.00 show=Nothing exclude include");
            run("Analyze Particles...", "size=1-1095635 circularity=0.00-1.00 show=Nothing include");
            updateResults();
            if (isOpen("Results")) {
                // ++++++++++++++++++++++++++
                nbA[totalvig] = nResults;
                // ++++++++++++++++++++++++++
                run("Clear Results");
            } // if
            if (test == "1") print("End of mesureA. CONTINUE ?");
            selectImage(titrered + "-1");
            close();
            // -------------- Mesure B ----------------------------
            selectImage(titrered);
            run("Duplicate...", titrered + "-1");
            setThreshold(0, Histcum2[totalvig]);
            run("Threshold", "thresholded remaining black");
            run("Erode");
            //		run("Analyze Particles...", "size=5-1095635 circularity=0.00-1.00 show=Nothing exclude include");
            run("Analyze Particles...", "size=1-1095635 circularity=0.00-1.00 show=Nothing include");

            updateResults();
            if (isOpen("Results")) {
                // ++++++++++++++++++++++++++
                nbB[totalvig] = nResults;
                // ++++++++++++++++++++++++++
                run("Clear Results");
            } // if
            if (test == "1") print("End of mesureB. CONTINUE ?");
            selectImage(titrered + "-1");
            close();
            // -------------- Mesure C et symï¿½trie C ----------------------------
            selectImage(titrered);
            run("Duplicate...", titrered + "-1");
            // --------------- Correction de Histcum3 si aucun pixel de cette valeur -----------------------------------------
            threshold3 = Histcum3[totalvig];
            while (hist[threshold3] == 0) {
                data3 = Histcum3[totalvig];
                Histcum3[totalvig] = data3 + 1;
                threshold3 = Histcum3[totalvig];
            } // while
            setThreshold(0, Histcum3[totalvig]);
            run("Threshold", "thresholded remaining black");
            // ------------------- symï¿½trie brute ----------------------
            image = "vignettesym";
            selectImage(titrered + "-1");
            HH = getHeight();
            WW = getWidth();
            if (isOpen("vignettesym")) {
                selectImage("vignettesym");
                close();
            } // if
            run("Duplicate...", "title=vignettesym");
            if (test == "1") print("End of duplicateC. CONTINUE ?");
            // --------------- Agrandissement de l'image -------------------------
            //	newImage("vignetteag", "8-bit White",WW*1.2, HH*1.2, 1);
            selectImage("vignettesym");
            largeursym = WW * 1.2;
            hauteursym = HH * 1.2;
            canvas = "width=" + largeursym + " height=" + hauteursym + " position=Center";
            run("Canvas Size...", canvas);
            run("Set Measurements...", "area centroid bounding fit redirect=[" + image + "] decimal=2");
            run("Analyze Particles...", "size=0-Infinity circularity=0.00-1.00 show=Nothing include record");
            // ------------------ Symetrie du plus gros objet de la vignette ---------------------------
            updateResults();
            if (test == "1") print("End of duplicateC2. CONTINUE ?");
            nbobj = nResults;
            ligne = 0;
            g = 0;
            Ratio = 0;
            // ---------------------- Si probleme de vignette blanche -----------------------------------
            if (nbobj == 0) {
                print(titrered + "  " + i + " " + Histcum3[totalvig]);
                selectImage(titrered);
                saveAs("Tif", chemwork + titrered + "_" + i + "_sympb");
                rename(titrered);
                showMessage(titrered + "  " + i + " " + Histcum3[i]);
            } //
            areainit = getResult("Area", ligne);
            while (g < nbobj) {
                area = getResult("Area", g);
                if (area > areainit) ligne = g;
                areainit = maxOf(area, areainit);
                g++;
            } // for

            if (areainit > 1) {
                if (test == "1") print("Area = " + areainit);

                bx = getResult("BX", ligne);
                by = getResult("BY", ligne);
                w = getResult("Width", ligne);
                h = getResult("Height", ligne);
                x = getResult("X", ligne);
                y = getResult("Y", ligne);
                area = getResult("Area", ligne);
                major = getResult("Major", ligne);
                angle = getResult("Angle", ligne);
                xstart = getResult("XStart", ligne);
                ystart = getResult("YStart", ligne);
                angle = angle + 180;
                angle = toString(angle);

                // --------------- nettoyage autour du plus gros objet -------------
                selectImage(image);
                DEBX = xstart;
                DEBY = ystart;
                doWand(DEBX, DEBY);
                run("Clear Outside");

                // ---------------- centrage ----------------------
                sum = w * w + h * h;
                diag = pow(sum, 0.5);
                diag = diag * 1.2;
                //	makeRectangle(bx,by,w,h);
                //	run("Copy");
                //	newImage("vignetteA", "8-bit White",diag, diag, 1);
                //	x = x-bx;
                //	y = y-by;
                //	posx = (diag/2)-x;
                //	posy = (diag/2)-y;
                //	makeRectangle(posx,posy,w,h);
                //	run("Paste");

                selectImage(image);
                rename("vignetteA");
                canvas = "width=" + diag + " height=" + diag + " position=Center";
                run("Canvas Size...", canvas);

                selectImage("vignetteA");
                run("Make Binary");
                run("Select None");
                rotation = "angle=" + angle + " interpolate";
                rotation = "angle=" + angle + " grid=1 fill";
                run("Arbitrarily...", rotation);
                run("Duplicate...", "title=vignetteB");

                //	selectImage(image);			close();


                if (test == "1") print("End of centrage. CONTINUE ?");

                // ------------- axe 1 ----------------------------
                run("Flip Horizontally");
                run("Image Calculator...", "image1=vignetteA operation=Difference image2=vignetteB create");
                selectImage("Result of vignetteA");
                getHistogram(0, hist, 256);
                areasym = hist[0];
                ratio1 = (areasym / 2) / area;
                selectImage("Result of vignetteA");
                close();
                if (test == "1") print("End of sym1. CONTINUE ?");
                // ------------- axe 2 ----------------------------
                selectImage("vignetteB");
                run("Make Binary");
                run("Flip Horizontally");
                selectImage("vignetteB");
                run("Flip Vertically");
                run("Image Calculator...", "image1=vignetteA operation=Difference image2=vignetteB create");
                selectImage("Result of vignetteA");
                //	run("Make Binary");
                getHistogram(0, hist, 256);
                areasym2 = hist[0];
                ratio2 = (areasym2 / 2) / area;
                if (test == "1") print("End of sym2. CONTINUE ?");
                // ------------------ Fermeture des vignettes -------------------------------------
                selectImage("Result of vignetteA");
                close();
                selectImage("vignetteA");
                close();
                selectImage("vignetteB");
                close();
                if (isOpen("Results")) {
                    selectWindow("Results");
                    run('Close');
                }
                // ++++++++++++++++++++++++++
                symetriehc[totalvig] = ratio1;
                symetrievc[totalvig] = ratio2;
                // ++++++++++++++++++++++++++
            } // if areainit
            selectImage(titrered + "-1");
            run("Erode");

            if (test == "1") print("End of Symetry2. CONTINUE ?");
            run("Set Measurements...", "area limit redirect=None decimal=0");
            //		run("Analyze Particles...", "size=5-1095635 circularity=0.00-1.00 show=Nothing exclude include");
            run("Analyze Particles...", "size=1-1095635 circularity=0.00-1.00 show=Nothing include");
            updateResults();
            if (isOpen("Results")) {
                // ++++++++++++++++++++++++++
                nbC[totalvig] = nResults;
                // ++++++++++++++++++++++++++
                run("Clear Results");
            } // if
            selectImage(titrered + "-1");
            close();

            // ------------------------ Fermeture de la vignette en niveaux de gris ----------------------------------------------------
            selectImage(titrered);
            close();

            // --------------------- Position du barycentre pondere apres gamma = 5 -----------------------------------------------
            selectImage("vignette_msk");
            //		run("Gamma...", "value=5");
            if (test == "1") print("End of Gamma. CONTINUE ?");


            //		selectImage("vignette_msk");
            //		doWand(DEBX,DEBY);
            //		run("Set Measurements...",parametres3);
            //		run("Measure");
            //		updateResults();
            //		xmg5 = 		getResult("XM",0);
            //		ymg5 = 		getResult("YM",0);
            // ++++++++++++++++++++++++++
            //		XMg5[totalvig] =	xmg5;
            //		YMg5[totalvig] = 	ymg5;
            // ++++++++++++++++++++++++++
            // 		run("Clear Results");

            if (test == "1") print("End of Gamma5. CONTINUE ?");

            // ------------------------ Fermeture de la vignette en niveaux de gris ----------------------------------------------------
            selectImage("vignette");
            close();
            // -------------------------On agrandit l'image de facon a obtenir une posibilite d'agrandissement pour les contours ----------
            selectImage("vignette_msk");
            L = getWidth();
            H = getHeight();
            makeRectangle(0, 0, L, H);
            run("Copy");
            if (L >= 200 && H >= 200) {
                Lf = 2 * L;
                Hf = 2 * H;
            } // if
            else {
                Lf = 4 * L;
                Hf = 4 * H;
            } // else
            Xs = floor(Lf / 2 - L / 2);
            Ys = floor(Hf / 2 - H / 2);
            newImage("temp", "8-bit White", Lf, Hf, 1);
            makeRectangle(Xs, Ys, L, H);
            run("Paste");

            //--------------------------------Skeleton Area--------------------------------------------------
            selectImage("vignette_msk");
            run("Skeletonize");
            getHistogram(0, histS, 256);
            histo0 = histS[0];
            // ++++++++++++++++++++++++++
            Skelarea[totalvig] = histo0;
            // ++++++++++++++++++++++++++
            if (option == "C") {
                selectImage("vignette_msk");
                saveAs("Tif", chemwork + titrered + "_" + i + "_skeleton");
                rename("vignette_msk");
            } // if
            selectImage("vignette_msk");
            close();
            if (test == "1") print("End of Skeleton. CONTINUE ?");
            //--------------------------------Fractal analyse-------------------------------------------------
            selectImage("temp");
            if (option == "C") {
                saveAs("Tif", chemwork + titrered + "_" + i + "_temp");
                rename("temp");
            } // if
            makeRectangle(0, 0, Lf, Hf);
            run("Copy");
            selectImage("temp");
            close();
            newImage("edm1", "8-bit White", Lf, Hf, 1);
            newImage("edm2", "8-bit White", Lf, Hf, 1);
            run("Paste");
            selectImage("edm1");
            run("Paste");
            run("Distance Map");
            if (option == "C") {
                saveAs("Tif", chemwork + titrered + "_" + i + "_edm1");
                rename("edm1");
            } // if
            selectImage("edm2");
            run("Invert");
            run("Distance Map");
            run("Invert");
            if (option == "C") {
                saveAs("Tif", chemwork + titrered + "_" + i + "_edm2");
                rename("edm2");
            } // if
            selectImage("edm1");
            run("Invert");
            run("Image Calculator...", "image1=edm1 operation=Add image2=edm2");
            selectImage("edm2");
            close();
            run("Clear Results");
            selectImage("edm1");
            run("Set Measurements...", "area limit decimal=3");
            if (isOpen("Log")) {
                selectWindow("Log");
                run("Close");
            } // if
            lg = 0;
            counter = 0;
            iterations = 40;
            sumg = 0;
            suma = 0;
            index = 0;
            Lg = newArray(iterations);
            Aire = newArray(iterations);
            for (k = 1; k <= iterations; k++) {
                y = round(pow(1.1, k));
                if (lg != y) {
                    lg = y;
                    selectImage("edm1");
                    setThreshold(0, lg);
                    run("Measure");
                    Lg[index] = log(2 * lg);
                    arr = getResult("Area", index);
                    Aire[index] = log(arr);
                    sumg = sumg + Lg[index];
                    suma = suma + Aire[index];
                    index++;
                } // if
            } // for
            selectImage("edm1");
            close();
            moyenneg = sumg / index;
            moyennea = suma / index;
            //---------Calcul de la pente de la regression  : stda/stdg -------------------
            secartg = 0;
            secarta = 0;
            for (t = 0; t < index; t++) {
                ecartgcar = pow(Lg[t] - moyenneg, 2);
                secartg = secartg + ecartgcar;
                ecartacar = pow(Aire[t] - moyennea, 2);
                secarta = secarta + ecartacar;
            } // for
            stdg = secartg * 1 / (index - 1);
            stdg = pow(stdg, 0.5);
            stda = secarta * 1 / (index - 1);
            stda = pow(stda, 0.5);
            // ++++++++++++++++++++++++++
            Fractal[totalvig] = 2 - stda / stdg;
            // ++++++++++++++++++++++++++
            if (test == "1") print("End of Fractal. CONTINUE ?");
            // --------------------- Gestion memoire --------------------------------------------------------------------
            if (i / 1000 == floor(i / 1000)) {
                p = i + 1;
                showStatus("Item  : " + p + " /" + nbblobs + "  => Release PC now ");
                for (b = 0; b < 4; b++) {
                    run("free memory");
                    wait(1000);
                } // for	
            } // if
            // -------------- Increment du no de vignette ----------------------------------
            totalvig++;
        } // if   ------------------ Vignette existe et apres FIRSTIMGOK et inf a profmax  -------------------------
    } // for i ---------------  boucle vignettes -----------------------------

    //====================  creer le tableau RESULTS =======================================================
    updateResults();
    selectWindow("Results");
    run("Close");
    //----------Mettre les bons resultats dans le tableau de nouveau------------------
    for (i = 0; i < totalvig; i++) {
        setResult("Label", i, listaff[i]);
        //	setResult("NoImage", i,Vigimg[i]);
        setResult("Z", i, Depth[i]);
        setResult("Area", i, Area[i]);
        setResult("Mean", i, Mean[i]);
        setResult("StdDev", i, StdDev[i]);
        setResult("Mode", i, Mode[i]);
        setResult("Min", i, Min[i]);
        setResult("Max", i, Max[i]);
        setResult("X", i, X[i]);
        setResult("Y", i, Y[i]);
        setResult("XM", i, XM[i]);
        setResult("YM", i, YM[i]);
        setResult("Perim.", i, Perim[i]);
        setResult("BX", i, BX[i]);
        setResult("BY", i, BY[i]);
        setResult("Width", i, WIDTH[i]);
        setResult("Height", i, HEIGTH[i]);
        setResult("Major", i, Major[i]);
        setResult("Minor", i, Minor[i]);
        setResult("Angle", i, Angle[i]);
        setResult("Circ.", i, Circ[i]);
        setResult("Feret", i, Feret[i]);
        setResult("IntDen", i, IntDen[i]);
        setResult("Median", i, Median[i]);
        setResult("Skew", i, Skew[i]);
        setResult("Kurt", i, Kurt[i]);
        setResult("%Area", i, PArea[i]);
        setResult("XStart", i, XSTART[i]);
        setResult("YStart", i, YSTART[i]);
        setResult("Area_exc", i, Area_exc[i]);
        setResult("Fractal", i, Fractal[i]);
        setResult("Skelarea", i, Skelarea[i]);
        if (option != "B") {
            setResult("Slope", i, Slope[i]);
            setResult("Histcum1", i, Histcum1[i]);
            setResult("Histcum2", i, Histcum2[i]);
            setResult("Histcum3", i, Histcum3[i]);
            setResult("XMg5", i, XMg5[i]);
            setResult("YMg5", i, YMg5[i]);
            setResult("Nb1", i, nbA[i]);
            setResult("Nb2", i, nbB[i]);
            setResult("Nb3", i, nbC[i]);
            setResult("Compentropy", i, compentropy[i]);
            setResult("Compmean", i, compmean[i]);
            setResult("Compslope", i, compslope[i]);
            setResult("CompM1", i, compm1[i]);
            setResult("CompM2", i, compm2[i]);
            setResult("CompM3", i, compm3[i]);
            setResult("Symetrieh", i, symetrieh[i]);
            setResult("Symetriev", i, symetriev[i]);
            setResult("Symetriehc", i, symetriehc[i]);
            setResult("Symetrievc", i, symetrievc[i]);
            setResult("Convperim", i, convperim[i]);
            setResult("Convarea", i, convarea[i]);
            setResult("Fcons", i, fcons[i]);
            setResult("ThickR", i, ratio[i]);
        } // if option

    } // for
    setBatchMode(false);

    // -------------------- Enregistrement RESULTS ----------------------------------
    updateResults();
    selectWindow("Results");
    saveAs("measurements", dirprocessed + profile + "_measurements.txt");

    // -------------------- ECRITURE PID -----------------------------------------------
    if (isOpen("Log")) {
        selectWindow("Log");
        run("Close");
    } // if
    print("PID");
    print("[Process]");
    dateheure = runMacro("Zooscan_get_time_5");
    print("Parametre_2= " + parametres2);
    print("Parametre_3= " + parametres3);
    print("Date= ", dateheure);
    print("First_image= " + firstimg);
    image0 = toString(image0);
    print("First_image_name= " + image0);

    totalvig = toString(totalvig);
    argpid = "UVP5 " + totalvig + " " + TAG + " " + titrered;
    argpid = runMacro("Zooscan_print_pid_5", argpid);
    flag = toString(argpid);
    l = lengthOf(flag);
    if (l == 1) {
        getBoolean("Error message : Print_pid_5 process aborted !    \n \nPress Cancel to abort !                   ");
    } // if
    selectWindow("Log");
    // ---------------- Enregistrement dans le repertoire du profile -------------
    sauvepid = "save=" + dirprocessed + profile + "_dat1.pid";
    run("Text...", sauvepid);
    // ----------------- Enregistrement dans pid_results de la mission ---------
    sauvepid = "save=" + dirpid + profile + "_dat1.pid";
    run("Text...", sauvepid);

} // process vignettes PID

selectWindow("Results");
run("Close");


// ----------------------------- FIN ----------------------------------------------
ret = "OK";
return ret;